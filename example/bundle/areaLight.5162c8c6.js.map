{"mappings":"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","sources":["src/index.js","src/core/PathTracingRenderer.js","src/materials/BlendMaterial.js","src/utils/SobolNumberMapGenerator.js","src/shader/shaderSobolSampling.js","src/core/DynamicPathTracingSceneGenerator.js","src/core/MaterialReducer.js","src/objects/PhysicalCamera.js","src/objects/EquirectCamera.js","src/objects/PhysicalSpotLight.js","src/objects/ShapedAreaLight.js","src/textures/GradientEquirectTexture.js","src/textures/ProceduralEquirectTexture.js","src/utils/BlurredEnvMapGenerator.js","src/utils/IESLoader.js","src/materials/DenoiseMaterial.js","src/materials/GraphMaterial.js","src/materials/PhysicalPathTracingMaterial.js","src/uniforms/MaterialsTexture.js","src/uniforms/utils.js","src/uniforms/RenderTarget2DArray.js","src/shader/shaderMaterialSampling.js","src/shader/shaderGGXFunctions.js","src/shader/shaderSheenFunctions.js","src/shader/shaderIridescenceFunctions.js","src/shader/shaderEnvMapSampling.js","src/shader/shaderLightSampling.js","src/shader/shaderLayerTexelFetchFunctions.js","src/uniforms/PhysicalCameraUniform.js","src/uniforms/EquirectHdrInfoUniform.js","src/uniforms/LightsInfoUniformStruct.js","src/uniforms/IESProfilesTexture.js","src/uniforms/AttributesTextureArray.js","src/uniforms/FloatAttributeTextureArray.js"],"sourcesContent":["// core\nexport * from './core/PathTracingRenderer.js';\nexport * from './core/PathTracingSceneGenerator.js';\nexport * from './core/DynamicPathTracingSceneGenerator.js';\nexport * from './core/MaterialReducer.js';\n\n// objects\nexport * from './objects/PhysicalCamera.js';\nexport * from './objects/EquirectCamera.js';\nexport * from './objects/PhysicalSpotLight.js';\nexport * from './objects/ShapedAreaLight.js';\n\n// textures\nexport * from './textures/ProceduralEquirectTexture.js';\nexport * from './textures/GradientEquirectTexture.js';\n\n// uniforms\nexport * from './uniforms/MaterialsTexture.js';\nexport * from './uniforms/RenderTarget2DArray.js';\nexport * from './uniforms/EquirectHdrInfoUniform.js';\nexport * from './uniforms/PhysicalCameraUniform.js';\nexport * from './uniforms/LightsInfoUniformStruct.js';\nexport * from './uniforms/IESProfilesTexture.js';\n\n// utils\nexport * from './utils/GeometryPreparationUtils.js';\nexport * from './utils/BlurredEnvMapGenerator.js';\nexport * from './utils/IESLoader.js';\n\n// materials\nexport * from './materials/DenoiseMaterial.js';\nexport * from './materials/GraphMaterial.js';\nexport * from './materials/MaterialBase.js';\nexport * from './materials/PhysicalPathTracingMaterial.js';\n\n// shaders\nexport * from './shader/shaderMaterialSampling.js';\nexport * from './shader/shaderUtils.js';\nexport * from './shader/shaderStructs.js';\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { BlendMaterial } from '../materials/BlendMaterial.js';\nimport { SobolNumberMapGenerator } from '../utils/SobolNumberMapGenerator.js';\n\nfunction* renderTask() {\n\n\tconst {\n\t\t_renderer,\n\t\t_fsQuad,\n\t\t_blendQuad,\n\t\t_primaryTarget,\n\t\t_blendTargets,\n\t\t_sobolTarget,\n\t\talpha,\n\t\tcamera,\n\t\tmaterial,\n\t} = this;\n\n\tconst blendMaterial = _blendQuad.material;\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\n\n\twhile ( true ) {\n\n\t\tif ( alpha ) {\n\n\t\t\tblendMaterial.opacity = 1 / ( this.samples + 1 );\n\t\t\tmaterial.blending = NoBlending;\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 1 / ( this.samples + 1 );\n\t\t\tmaterial.blending = NormalBlending;\n\n\t\t}\n\n\t\tconst w = _primaryTarget.width;\n\t\tconst h = _primaryTarget.height;\n\t\tmaterial.resolution.set( w, h );\n\t\tmaterial.sobolTexture = _sobolTarget.texture;\n\t\tmaterial.seed ++;\n\n\t\tconst tilesX = this.tiles.x || 1;\n\t\tconst tilesY = this.tiles.y || 1;\n\t\tconst totalTiles = tilesX * tilesY;\n\t\tconst dprInv = ( 1 / _renderer.getPixelRatio() );\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\n\n\t\t\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\n\t\t\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\n\n\t\t\t\t// Perspective camera (default)\n\t\t\t\tlet cameraType = 0;\n\n\t\t\t\t// An orthographic projection matrix will always have the bottom right element == 1\n\t\t\t\t// And a perspective projection matrix will always have the bottom right element == 0\n\t\t\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\n\n\t\t\t\t\t// Orthographic\n\t\t\t\t\tcameraType = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( camera.isEquirectCamera ) {\n\n\t\t\t\t\t// Equirectangular\n\t\t\t\t\tcameraType = 2;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\n\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\n\n\t\t\t\tlet tx = x;\n\t\t\t\tlet ty = y;\n\t\t\t\tif ( ! this.stableTiles ) {\n\n\t\t\t\t\tconst tileIndex = ( this._currentTile ) % ( tilesX * tilesY );\n\t\t\t\t\ttx = tileIndex % tilesX;\n\t\t\t\t\tty = ~ ~ ( tileIndex / tilesX );\n\n\t\t\t\t\tthis._currentTile = tileIndex + 1;\n\n\t\t\t\t}\n\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t\t\t_renderer.setScissorTest( true );\n\t\t\t\t_renderer.setScissor(\n\t\t\t\t\tdprInv * Math.ceil( tx * w / tilesX ),\n\t\t\t\t\tdprInv * Math.ceil( ( tilesY - ty - 1 ) * h / tilesY ),\n\t\t\t\t\tdprInv * Math.ceil( w / tilesX ),\n\t\t\t\t\tdprInv * Math.ceil( h / tilesY ) );\n\t\t\t\t_renderer.autoClear = false;\n\t\t\t\t_fsQuad.render( _renderer );\n\n\t\t\t\t_renderer.setScissorTest( false );\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\t\t\t\t_renderer.autoClear = ogAutoClear;\n\n\t\t\t\tif ( alpha ) {\n\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\n\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\n\t\t\t\t\t_blendQuad.render( _renderer );\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tthis.samples += ( 1 / totalTiles );\n\n\t\t\t\tyield;\n\n\t\t\t}\n\n\t\t}\n\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\n\n\t\tthis.samples = Math.round( this.samples );\n\n\t}\n\n}\n\nconst ogClearColor = new Color();\nexport class PathTracingRenderer {\n\n\tget material() {\n\n\t\treturn this._fsQuad.material;\n\n\t}\n\n\tset material( v ) {\n\n\t\tthis._fsQuad.material = v;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\n\n\t}\n\n\tset alpha( v ) {\n\n\t\tif ( ! v ) {\n\n\t\t\tthis._blendTargets[ 0 ].dispose();\n\t\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\t}\n\n\t\tthis._alpha = v;\n\t\tthis.reset();\n\n\t}\n\n\tget alpha() {\n\n\t\treturn this._alpha;\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\tthis.camera = null;\n\t\tthis.tiles = new Vector2( 1, 1 );\n\n\t\tthis.samples = 0;\n\t\tthis.stableNoise = false;\n\t\tthis.stableTiles = true;\n\n\t\tthis._renderer = renderer;\n\t\tthis._alpha = false;\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\n\t\tthis._task = null;\n\t\tthis._currentTile = 0;\n\n\t\tthis._sobolTarget = new SobolNumberMapGenerator().generate( renderer );\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: FloatType,\n\t\t} );\n\t\tthis._blendTargets = [\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t} ),\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t} ),\n\t\t];\n\n\t}\n\n\tsetSize( w, h ) {\n\n\t\tthis._primaryTarget.setSize( w, h );\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\n\t\tthis.reset();\n\n\t}\n\n\tdispose() {\n\n\t\tthis._primaryTarget.dispose();\n\t\tthis._blendTargets[ 0 ].dispose();\n\t\tthis._blendTargets[ 1 ].dispose();\n\t\tthis._sobolTarget.dispose();\n\n\t\tthis._fsQuad.dispose();\n\t\tthis._blendQuad.dispose();\n\t\tthis._task = null;\n\n\t}\n\n\treset() {\n\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.getClearColor( ogClearColor );\n\n\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\n\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\tthis.samples = 0;\n\t\tthis._task = null;\n\n\t\tif ( this.stableNoise ) {\n\n\t\t\tthis.material.seed = 0;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tif ( ! this._task ) {\n\n\t\t\tthis._task = renderTask.call( this );\n\n\t\t}\n\n\t\tthis._task.next();\n\n\t}\n\n}\n","import { NoBlending } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\n\nexport class BlendMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\ttarget1: { value: null },\n\t\t\t\ttarget2: { value: null },\n\t\t\t\topacity: { value: 1.0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { FloatType, NearestFilter, NoBlending, RGBAFormat, Vector2, WebGLRenderTarget } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { shaderSobolCommon, shaderSobolGeneration } from '../shader/shaderSobolSampling.js';\n\nclass SobolNumbersMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t${ shaderSobolCommon }\n\t\t\t\t${ shaderSobolGeneration }\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class SobolNumberMapGenerator {\n\n\tgenerate( renderer, dimensions = 256 ) {\n\n\t\tconst target = new WebGLRenderTarget( dimensions, dimensions, {\n\n\t\t\ttype: FloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tminFilter: NearestFilter,\n\t\t\tmagFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\n\t\t} );\n\n\t\tconst ogTarget = renderer.getRenderTarget();\n\t\trenderer.setRenderTarget( target );\n\n\t\tconst quad = new FullScreenQuad( new SobolNumbersMaterial() );\n\t\tquad.material.resolution.set( dimensions, dimensions );\n\t\tquad.render( renderer );\n\n\t\trenderer.setRenderTarget( ogTarget );\n\t\tquad.dispose();\n\n\t\treturn target;\n\n\t}\n\n}\n","// References\n// - https://jcgt.org/published/0009/04/01/\n// - Code from https://www.shadertoy.com/view/WtGyDm\n\n// functions to generate multi-dimensions variables of the same functions\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\nfunction generateSobolFunctionVariants( dim = 1 ) {\n\n\tlet type = 'uint';\n\tif ( dim > 1 ) {\n\n\t\ttype = 'uvec' + dim;\n\n\t}\n\n\treturn /* glsl */`\n\t\t${ type } sobolReverseBits( ${ type } x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${ type } sobolHashCombine( uint seed, ${ type } v ) {\n\n\t\t\treturn seed ^ ( v + ${ type }( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${ type } sobolLaineKarrasPermutation( ${ type } x, ${ type } seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${ type } nestedUniformScrambleBase2( ${ type } x, ${ type } seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`;\n\n}\n\nfunction generateSobolSampleFunctions( dim = 1 ) {\n\n\tlet utype = 'uint';\n\tlet vtype = 'float';\n\tlet num = '';\n\tlet components = '.r';\n\tlet combineValues = '1u';\n\tif ( dim > 1 ) {\n\n\t\tutype = 'uvec' + dim;\n\t\tvtype = 'vec' + dim;\n\t\tnum = dim + '';\n\t\tif ( dim === 2 ) {\n\n\t\t\tcomponents = '.rg';\n\t\t\tcombineValues = 'uvec2( 1u, 2u )';\n\n\t\t} else if ( dim === 3 ) {\n\n\t\t\tcomponents = '.rgb';\n\t\t\tcombineValues = 'uvec3( 1u, 2u, 3u )';\n\n\t\t} else {\n\n\t\t\tcomponents = '';\n\t\t\tcombineValues = 'uvec4( 1u, 2u, 3u, 4u )';\n\n\t\t}\n\n\t}\n\n\treturn /* glsl */`\n\n\t\t${ vtype } sobol${ num }( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${ vtype } sobol_pt = sobolGetTexturePoint( shuffled_index )${ components };\n\t\t\t${ utype } result = ${ utype }( sobol_pt * 16777216.0 );\n\n\t\t\t${ utype } seed2 = sobolHashCombine( seed, ${ combineValues } );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${ vtype }( result >> 8 );\n\n\t\t}\n\t`;\n\n}\n\nexport const shaderSobolCommon = /* glsl */`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${ generateSobolFunctionVariants( 1 ) }\n\t${ generateSobolFunctionVariants( 2 ) }\n\t${ generateSobolFunctionVariants( 3 ) }\n\t${ generateSobolFunctionVariants( 4 ) }\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`;\n\nexport const shaderSobolGeneration = /* glsl */`\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTEL this sobol \"direction\" is also available but we can't write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n`;\n\nexport const shaderSobolSampling = /* glsl */`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex;\n\tuint sobolPathIndex;\n\tuint sobolBounceIndex;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${ generateSobolSampleFunctions( 1 ) }\n\t${ generateSobolSampleFunctions( 2 ) }\n\t${ generateSobolSampleFunctions( 3 ) }\n\t${ generateSobolSampleFunctions( 4 ) }\n\n`;\n","import { BufferGeometry } from 'three';\nimport { StaticGeometryGenerator, MeshBVH } from 'three-mesh-bvh';\nimport { setCommonAttributes, getGroupMaterialIndicesAttribute } from '../utils/GeometryPreparationUtils.js';\n\nexport class DynamicPathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( scene ) {\n\n\t\tthis.objects = Array.isArray( scene ) ? scene : [ scene ];\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.lights = [];\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.objects );\n\n\t}\n\n\treset() {\n\n\t\tthis.bvh = null;\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.lights = [];\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.objects );\n\n\t}\n\n\tdispose() {}\n\n\tgenerate() {\n\n\t\tconst { objects, staticGeometryGenerator, geometry } = this;\n\t\tif ( this.bvh === null ) {\n\n\t\t\tconst attributes = [ 'position', 'normal', 'tangent', 'uv', 'color' ];\n\n\t\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tobjects[ i ].traverse( c => {\n\n\t\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\t\tconst normalMapRequired = ! ! c.material.normalMap;\n\t\t\t\t\t\tsetCommonAttributes( c.geometry, { attributes, normalMapRequired } );\n\n\t\t\t\t\t} else if ( c.isRectAreaLight || c.isSpotLight ) {\n\n\t\t\t\t\t\tthis.lights.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst textureSet = new Set();\n\t\t\tconst materials = staticGeometryGenerator.getMaterials();\n\t\t\tmaterials.forEach( material => {\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextureSet.add( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tstaticGeometryGenerator.attributes = attributes;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\n\t\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, materials, materials );\n\t\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\t\t\tgeometry.clearGroups();\n\n\t\t\tthis.bvh = new MeshBVH( geometry );\n\t\t\tthis.materials = materials;\n\t\t\tthis.textures = Array.from( textureSet );\n\n\t\t\treturn {\n\t\t\t\tlights: this.lights,\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tobjects,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst { bvh } = this;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\t\t\tbvh.refit();\n\t\t\treturn {\n\t\t\t\tlights: this.lights,\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tobjects,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import { PerspectiveCamera } from 'three';\n\nexport class PhysicalCamera extends PerspectiveCamera {\n\n\tset bokehSize( size ) {\n\n\t\tthis.fStop = this.getFocalLength() / size;\n\n\t}\n\n\tget bokehSize() {\n\n\t\treturn this.getFocalLength() / this.fStop;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.fStop = 1.4;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 25;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n}\n","import { Camera } from 'three';\n\nexport class EquirectCamera extends Camera {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isEquirectCamera = true;\n\n\t}\n\n}\n","import { SpotLight } from 'three';\n\nexport class PhysicalSpotLight extends SpotLight {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.iesTexture = null;\n\t\tthis.radius = 0;\n\n\t}\n\n}\n","import { RectAreaLight } from 'three';\n\nexport class ShapedAreaLight extends RectAreaLight {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isCircular = false;\n\n\t}\n\n}\n","import { Color, Vector3 } from 'three';\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\n\nconst _direction = new Vector3();\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\n\n\tconstructor( resolution = 512 ) {\n\n\t\tsuper( resolution, resolution );\n\n\t\tthis.topColor = new Color().set( 0xffffff );\n\t\tthis.bottomColor = new Color().set( 0x000000 );\n\t\tthis.exponent = 2;\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\n\n\t\t\t_direction.setFromSpherical( polar );\n\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\n\n\t\t};\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\n\t\tthis.topColor.copy( other.topColor );\n\t\tthis.bottomColor.copy( other.bottomColor );\n\t\treturn this;\n\n\t}\n\n}\n","import {\n\tClampToEdgeWrapping,\n\tColor,\n\tDataTexture,\n\tEquirectangularReflectionMapping,\n\tFloatType,\n\tLinearFilter,\n\tRepeatWrapping,\n\tRGBAFormat,\n\tSpherical,\n\tVector2,\n} from 'three';\n\nconst _uv = new Vector2();\nconst _coord = new Vector2();\nconst _polar = new Spherical();\nconst _color = new Color();\nexport class ProceduralEquirectTexture extends DataTexture {\n\n\tconstructor( width, height ) {\n\n\t\tsuper(\n\t\t\tnew Float32Array( width * height * 4 ),\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\n\t\t);\n\n\t\tthis.generationCallback = null;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t\tconst { data, width, height } = this.image;\n\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\t_coord.set( width, height );\n\n\t\t\t\t_uv.set( x / width, y / height );\n\t\t\t\t_uv.x -= 0.5;\n\t\t\t\t_uv.y = 1.0 - _uv.y;\n\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\n\t\t\t\t_polar.radius = 1.0;\n\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst i4 = 4 * i;\n\t\t\t\tdata[ i4 + 0 ] = _color.r;\n\t\t\t\tdata[ i4 + 1 ] = _color.g;\n\t\t\t\tdata[ i4 + 2 ] = _color.b;\n\t\t\t\tdata[ i4 + 3 ] = 1.0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.generationCallback = other.generationCallback;\n\t\treturn this;\n\n\t}\n\n}\n","import { WebGLRenderTarget, RGBAFormat, FloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\n\nclass PMREMCopyMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tblur: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ shaderUtils }\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class BlurredEnvMapGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.pmremGenerator.dispose();\n\t\tthis.copyQuad.dispose();\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\tgenerate( texture, blur ) {\n\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\n\n\t\t// get the pmrem target\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\n\n\t\t// set up the material\n\t\tconst { width, height } = texture.image;\n\t\trenderTarget.setSize( width, height );\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\n\t\tcopyQuad.material.blur = blur;\n\n\t\t// render\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\t\tcopyQuad.render( renderer );\n\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.autoClear = prevClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, buffer );\n\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, FloatType );\n\t\tresult.minFilter = texture.minFilter;\n\t\tresult.magFilter = texture.magFilter;\n\t\tresult.wrapS = texture.wrapS;\n\t\tresult.wrapT = texture.wrapT;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\t// dispose of the now unneeded target\n\t\tpmremTarget.dispose();\n\n\t\treturn result;\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFileLoader,\n\tFloatType,\n\tLinearFilter,\n\tRedFormat,\n\tMathUtils,\n\tLoader,\n} from 'three';\n\nfunction IESLamp( text ) {\n\n\tconst _self = this;\n\n\tconst textArray = text.split( '\\n' );\n\n\tlet lineNumber = 0;\n\tlet line;\n\n\t_self.verAngles = [ ];\n\t_self.horAngles = [ ];\n\n\t_self.candelaValues = [ ];\n\n\t_self.tiltData = { };\n\t_self.tiltData.angles = [ ];\n\t_self.tiltData.mulFactors = [ ];\n\n\tfunction textToArray( text ) {\n\n\t\ttext = text.trim(); // remove leading or trailing spaces\n\t\ttext = text.replace( /,/g, ' ' ); // replace commas with spaces\n\t\ttext = text.replace( /\\s\\s+/g, ' ' ); // replace white space/tabs etc by single whitespace\n\n\t\tconst array = text.split( ' ' );\n\n\t\treturn array;\n\n\t}\n\n\tfunction readArray( count, array ) {\n\n\t\twhile ( true ) {\n\n\t\t\tconst line = textArray[ lineNumber ++ ];\n\t\t\tconst lineData = textToArray( line );\n\n\t\t\tfor ( let i = 0; i < lineData.length; ++ i ) {\n\n\t\t\t\tarray.push( Number( lineData[ i ] ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length === count )\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction readTilt() {\n\n\t\tlet line = textArray[ lineNumber ++ ];\n\t\tlet lineData = textToArray( line );\n\n\t\t_self.tiltData.lampToLumGeometry = Number( lineData[ 0 ] );\n\n\t\tline = textArray[ lineNumber ++ ];\n\t\tlineData = textToArray( line );\n\n\t\t_self.tiltData.numAngles = Number( lineData[ 0 ] );\n\n\t\treadArray( _self.tiltData.numAngles, _self.tiltData.angles );\n\t\treadArray( _self.tiltData.numAngles, _self.tiltData.mulFactors );\n\n\t}\n\n\tfunction readLampValues() {\n\n\t\tconst values = [ ];\n\t\treadArray( 10, values );\n\n\t\t_self.count = Number( values[ 0 ] );\n\t\t_self.lumens = Number( values[ 1 ] );\n\t\t_self.multiplier = Number( values[ 2 ] );\n\t\t_self.numVerAngles = Number( values[ 3 ] );\n\t\t_self.numHorAngles = Number( values[ 4 ] );\n\t\t_self.gonioType = Number( values[ 5 ] );\n\t\t_self.units = Number( values[ 6 ] );\n\t\t_self.width = Number( values[ 7 ] );\n\t\t_self.length = Number( values[ 8 ] );\n\t\t_self.height = Number( values[ 9 ] );\n\n\t}\n\n\tfunction readLampFactors() {\n\n\t\tconst values = [ ];\n\t\treadArray( 3, values );\n\n\t\t_self.ballFactor = Number( values[ 0 ] );\n\t\t_self.blpFactor = Number( values[ 1 ] );\n\t\t_self.inputWatts = Number( values[ 2 ] );\n\n\t}\n\n\twhile ( true ) {\n\n\t\tline = textArray[ lineNumber ++ ];\n\n\t\tif ( line.includes( 'TILT' ) ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tif ( ! line.includes( 'NONE' ) ) {\n\n\t\tif ( line.includes( 'INCLUDE' ) ) {\n\n\t\t\treadTilt();\n\n\t\t} else {\n\n\t\t\t// TODO:: Read tilt data from a file\n\n\t\t}\n\n\t}\n\n\treadLampValues();\n\n\treadLampFactors();\n\n\t// Initialize candela value array\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\t_self.candelaValues.push( [ ] );\n\n\t}\n\n\t// Parse Angles\n\treadArray( _self.numVerAngles, _self.verAngles );\n\treadArray( _self.numHorAngles, _self.horAngles );\n\n\t// Parse Candela values\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\treadArray( _self.numVerAngles, _self.candelaValues[ i ] );\n\n\t}\n\n\t// Calculate actual candela values, and normalize.\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\tfor ( let j = 0; j < _self.numVerAngles; ++ j ) {\n\n\t\t\t_self.candelaValues[ i ][ j ] *= _self.candelaValues[ i ][ j ] * _self.multiplier\n\t\t\t\t* _self.ballFactor * _self.blpFactor;\n\n\t\t}\n\n\t}\n\n\tlet maxVal = - 1;\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\tfor ( let j = 0; j < _self.numVerAngles; ++ j ) {\n\n\t\t\tconst value = _self.candelaValues[ i ][ j ];\n\t\t\tmaxVal = maxVal < value ? value : maxVal;\n\n\t\t}\n\n\t}\n\n\tconst bNormalize = true;\n\tif ( bNormalize && maxVal > 0 ) {\n\n\t\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\t\tfor ( let j = 0; j < _self.numVerAngles; ++ j ) {\n\n\t\t\t\t_self.candelaValues[ i ][ j ] /= maxVal;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport class IESLoader extends Loader {\n\n\t_getIESValues( iesLamp ) {\n\n\t\tconst width = 360;\n\t\tconst height = 180;\n\t\tconst size = width * height;\n\n\t\tconst data = new Float32Array( size );\n\n\t\tfunction interpolateCandelaValues( phi, theta ) {\n\n\t\t\tlet phiIndex = 0, thetaIndex = 0;\n\t\t\tlet startTheta = 0, endTheta = 0, startPhi = 0, endPhi = 0;\n\n\t\t\tfor ( let i = 0; i < iesLamp.numHorAngles - 1; ++ i ) { // numHorAngles = horAngles.length-1 because of extra padding, so this wont cause an out of bounds error\n\n\t\t\t\tif ( theta < iesLamp.horAngles[ i + 1 ] || i == iesLamp.numHorAngles - 2 ) {\n\n\t\t\t\t\tthetaIndex = i;\n\t\t\t\t\tstartTheta = iesLamp.horAngles[ i ];\n\t\t\t\t\tendTheta = iesLamp.horAngles[ i + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < iesLamp.numVerAngles - 1; ++ i ) {\n\n\t\t\t\tif ( phi < iesLamp.verAngles[ i + 1 ] || i == iesLamp.numVerAngles - 2 ) {\n\n\t\t\t\t\tphiIndex = i;\n\t\t\t\t\tstartPhi = iesLamp.verAngles[ i ];\n\t\t\t\t\tendPhi = iesLamp.verAngles[ i + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deltaTheta = endTheta - startTheta;\n\t\t\tconst deltaPhi = endPhi - startPhi;\n\n\t\t\tif ( deltaPhi === 0 ) // Outside range\n\t\t\t\treturn 0;\n\n\t\t\tconst t1 = deltaTheta === 0 ? 0 : ( theta - startTheta ) / deltaTheta;\n\t\t\tconst t2 = ( phi - startPhi ) / deltaPhi;\n\n\t\t\tconst nextThetaIndex = deltaTheta === 0 ? thetaIndex : thetaIndex + 1;\n\n\t\t\tconst v1 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex ], t1 );\n\t\t\tconst v2 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex + 1 ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex + 1 ], t1 );\n\t\t\tconst v = MathUtils.lerp( v1, v2, t2 );\n\n\t\t\treturn v;\n\n\t\t}\n\n\t\tconst startTheta = iesLamp.horAngles[ 0 ], endTheta = iesLamp.horAngles[ iesLamp.numHorAngles - 1 ];\n\t\tfor ( let i = 0; i < size; ++ i ) {\n\n\t\t\tlet theta = i % width;\n\t\t\tconst phi = Math.floor( i / width );\n\n\t\t\tif ( endTheta - startTheta !== 0 && ( theta < startTheta || theta >= endTheta ) ) { // Handle symmetry for hor angles\n\n\t\t\t\ttheta %= endTheta * 2;\n\t\t\t\tif ( theta > endTheta )\n\t\t\t\t\ttheta = endTheta * 2 - theta;\n\n\t\t\t}\n\n\t\t\tdata[ i ] = interpolateCandelaValues( phi, theta );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'text' );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\n\t\tconst texture = new DataTexture( null, 360, 180, RedFormat, FloatType );\n\t\ttexture.minFilter = LinearFilter;\n\t\ttexture.magFilter = LinearFilter;\n\n\t\tloader.load( url, text => {\n\n\t\t\tconst iesLamp = new IESLamp( text );\n\n\t\t\ttexture.image.data = this._getIESValues( iesLamp );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst iesLamp = new IESLamp( text );\n\t\tconst texture = new DataTexture( null, 360, 180, RedFormat, FloatType );\n\t\ttexture.minFilter = LinearFilter;\n\t\ttexture.magFilter = LinearFilter;\n\t\ttexture.image.data = this._getIESValues( iesLamp );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n","import { NoBlending } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\n\nexport class DenoiseMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\ttransparent: false,\n\n\t\t\tdepthWrite: false,\n\n\t\t\tdepthTest: false,\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SLIDER: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsigma: { value: 5.0 },\n\t\t\t\tthreshold: { value: 0.03 },\n\t\t\t\tkSigma: { value: 1.0 },\n\n\t\t\t\tmap: { value: null },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\n\t\t\t\t//  All rights reserved.\n\t\t\t\t//\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\n\t\t\t\t//\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\n\t\t\t\t//\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\n\t\t\t\t//\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tuniform float sigma;\n\t\t\t\tuniform float threshold;\n\t\t\t\tuniform float kSigma;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\n\n\t\t\t\t// Parameters:\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\n\t\t\t\t//\t\t kSigma * sigma  -->  radius of the circular kernel\n\t\t\t\t//\t float threshold   - edge sharpening threshold\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\n\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\n\t\t\t\t\tfloat radQ = radius * radius;\n\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\n\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\n\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\n\n\t\t\t\t\tfloat zBuff = 0.0;\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\n\n\t\t\t\t\tvec2 d;\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\n\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\n\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\n\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\n\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\n\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\n\n\t\t\t\t\t\t\tzBuff += deltaFactor;\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aBuff / zBuff;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <encodings_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { NoBlending, Color, Vector2, Vector4 } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\n\nexport class GraphMaterial extends MaterialBase {\n\n\tget graphFunctionSnippet() {\n\n\t\treturn this._graphFunctionSnippet;\n\n\t}\n\n\tset graphFunctionSnippet( v ) {\n\n\t\tthis._graphFunctionSnippet = v;\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\ttransparent: false,\n\n\t\t\tdepthWrite: false,\n\n\t\t\tdepthTest: false,\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SLIDER: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tdim: { value: true },\n\t\t\t\tthickness: { value: 1 },\n\t\t\t\tgraphCount: { value: 4 },\n\t\t\t\tgraphDisplay: { value: new Vector4( 1.0, 1.0, 1.0, 1.0 ) },\n\t\t\t\toverlay: { value: true },\n\t\t\t\txRange: { value: new Vector2( - 2.0, 2.0 ) },\n\t\t\t\tyRange: { value: new Vector2( - 2.0, 2.0 ) },\n\t\t\t\tcolors: { value: [\n\t\t\t\t\tnew Color( 0xe91e63 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0x4caf50 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0x03a9f4 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0xffc107 ).convertSRGBToLinear(),\n\t\t\t\t] },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform bool overlay;\n\t\t\t\tuniform bool dim;\n\t\t\t\tuniform bvec4 graphDisplay;\n\t\t\t\tuniform float graphCount;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 xRange;\n\t\t\t\tuniform vec2 yRange;\n\t\t\t\tuniform vec3 colors[ 4 ];\n\n\t\t\t\t__FUNCTION_CONTENT__\n\n\t\t\t\tfloat map( float _min, float _max, float v ) {\n\n\t\t\t\t\tfloat len = _max - _min;\n\t\t\t\t\treturn _min + len * v;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getBackground( vec2 point, float steepness ) {\n\n\t\t\t\t\tvec2 pw = fwidth( point );\n\t\t\t\t\tvec2 halfWidth = pw * 0.5;\n\n\t\t\t\t\t// x, y axes\n\t\t\t\t\tvec2 distToZero = smoothstep(\n\t\t\t\t\t\t- halfWidth * 0.5,\n\t\t\t\t\t\thalfWidth * 0.5,\n\t\t\t\t\t\tabs( point.xy ) - pw\n\t\t\t\t\t);\n\n\t\t\t\t\t// 1 unit markers\n\t\t\t\t\tvec2 temp;\n\t\t\t\t\tvec2 modAxis = abs( modf( point + vec2( 0.5 ), temp ) ) - 0.5;\n\t\t\t\t\tvec2 distToAxis = smoothstep(\n\t\t\t\t\t\t- halfWidth,\n\t\t\t\t\t\thalfWidth,\n\t\t\t\t\t\tabs( modAxis.xy ) - pw * 0.5\n\t\t\t\t\t);\n\n\t\t\t\t\t// if we're at a chart boundary then remove the artifacts\n\t\t\t\t\tif ( abs( pw.y ) > steepness * 0.5 ) {\n\n\t\t\t\t\t\tdistToZero.y = 1.0;\n\t\t\t\t\t\tdistToAxis.y = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mix colors into a background color\n\t\t\t\t\tfloat axisIntensity = 1.0 - min( distToZero.x, distToZero.y );\n\t\t\t\t\tfloat markerIntensity = 1.0 - min( distToAxis.x, distToAxis.y );\n\n\t\t\t\t\tvec3 markerColor = mix( vec3( 0.005 ), vec3( 0.05 ), markerIntensity );\n\t\t\t\t\tvec3 backgroundColor = mix( markerColor, vec3( 0.2 ), axisIntensity );\n\t\t\t\t\treturn backgroundColor;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// from uniforms\n\t\t\t\t\tfloat sectionCount = overlay ? 1.0 : graphCount;\n\t\t\t\t\tfloat yWidth = abs( yRange.y - yRange.x );\n\n\t\t\t\t\t// separate into sections\n\t\t\t\t\tfloat _section;\n\t\t\t\t\tfloat sectionY = modf( sectionCount * vUv.y, _section );\n\t\t\t\t\tint section = int( sectionCount - _section - 1.0 );\n\n\t\t\t\t\t// get the current point\n\t\t\t\t\tvec2 point = vec2(\n\t\t\t\t\t\tmap( xRange.x, xRange.y, vUv.x ),\n\t\t\t\t\t\tmap( yRange.x, yRange.y, sectionY )\n\t\t\t\t\t);\n\n\t\t\t\t\t// get the results\n\t\t\t\t\tvec4 result = graphFunction( point.x );\n\t\t\t\t\tvec4 delta = result - vec4( point.y );\n\t\t\t\t\tvec4 halfDdf = fwidth( delta ) * 0.5;\n\t\t\t\t\tif ( fwidth( point.y ) > yWidth * 0.5 ) {\n\n\t\t\t\t\t\thalfDdf = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph display intensity\n\t\t\t\t\tvec4 graph = smoothstep( - halfDdf, halfDdf, abs( delta ) - thickness * halfDdf );\n\n\t\t\t\t\t// initialize the background\n\t\t\t\t\tgl_FragColor.rgb = getBackground( point, yWidth );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\tif ( dim && ( point.x < 0.0 || point.y < 0.0 ) ) {\n\n\t\t\t\t\t\tgraph = mix(\n\t\t\t\t\t\t\tvec4( 1.0 ),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t0.05\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// color the charts\n\t\t\t\t\tif ( sectionCount > 1.0 ) {\n\n\t\t\t\t\t\tif ( graphDisplay[ section ] ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\tcolors[ section ],\n\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\tgraph[ section ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( int i = 0; i < int( graphCount ); i ++ ) {\n\n\t\t\t\t\t\t\tif ( graphDisplay[ i ] ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\t\tcolors[ i ],\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\t\tgraph[ i ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\n\t\tthis._graphFunctionSnippet = /* glsl */`\n\t\t\tvec4 graphFunctionSnippet( float x ) {\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tsin( x * 3.1415926535 ),\n\t\t\t\t\tcos( x ),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t);\n\n\t\t\t}\n\t\t`;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tonBeforeCompile( shader ) {\n\n\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t'__FUNCTION_CONTENT__',\n\t\t\tthis._graphFunctionSnippet,\n\t\t);\n\t\treturn shader;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this._graphFunctionSnippet;\n\n\t}\n\n}\n","import { Matrix4, Vector2 } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\nimport {\n\tMeshBVHUniformStruct, UIntVertexAttributeTexture,\n\tshaderStructs, shaderIntersectFunction,\n} from 'three-mesh-bvh';\nimport { shaderMaterialStructs, shaderLightStruct } from '../shader/shaderStructs.js';\nimport { MaterialsTexture } from '../uniforms/MaterialsTexture.js';\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\nimport { shaderMaterialSampling } from '../shader/shaderMaterialSampling.js';\nimport { shaderEnvMapSampling } from '../shader/shaderEnvMapSampling.js';\nimport { shaderLightSampling } from '../shader/shaderLightSampling.js';\nimport { shaderSobolCommon, shaderSobolSampling } from '../shader/shaderSobolSampling.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\nimport { shaderLayerTexelFetchFunctions } from '../shader/shaderLayerTexelFetchFunctions.js';\nimport { shaderRandFunctions } from '../shader/shaderRandFunctions.js';\nimport { PhysicalCameraUniform } from '../uniforms/PhysicalCameraUniform.js';\nimport { EquirectHdrInfoUniform } from '../uniforms/EquirectHdrInfoUniform.js';\nimport { LightsInfoUniformStruct } from '../uniforms/LightsInfoUniformStruct.js';\nimport { IESProfilesTexture } from '../uniforms/IESProfilesTexture.js';\nimport { AttributesTextureArray } from '../uniforms/AttributesTextureArray.js';\n\nexport class PhysicalPathTracingMaterial extends MaterialBase {\n\n\tonBeforeRender() {\n\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\n\t\tthis.setDefine( 'FEATURE_BACKGROUND_MAP', this.backgroundMap ? 1 : 0 );\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t\tdefines: {\n\t\t\t\tFEATURE_MIS: 1,\n\t\t\t\tFEATURE_DOF: 1,\n\t\t\t\tFEATURE_BACKGROUND_MAP: 0,\n\t\t\t\tTRANSPARENT_TRAVERSALS: 5,\n\t\t\t\t// 0 = Perspective\n\t\t\t\t// 1 = Orthographic\n\t\t\t\t// 2 = Equirectangular\n\t\t\t\tCAMERA_TYPE: 0,\n\n\t\t\t\tATTR_NORMAL: 0,\n\t\t\t\tATTR_TANGENT: 1,\n\t\t\t\tATTR_UV: 2,\n\t\t\t\tATTR_COLOR: 3,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t\tbounces: { value: 3 },\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\n\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tattributesArray: { value: new AttributesTextureArray() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tlights: { value: new LightsInfoUniformStruct() },\n\t\t\t\tiesProfiles: { value: new IESProfilesTexture().texture },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tbackgroundBlur: { value: 0.0 },\n\t\t\t\tenvironmentIntensity: { value: 1.0 },\n\t\t\t\tenvironmentRotation: { value: new Matrix4() },\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\n\t\t\t\tbackgroundMap: { value: null },\n\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tfilterGlossyFactor: { value: 0.0 },\n\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\n\t\t\t\tsobolTexture: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t${ shaderRandFunctions }\n\t\t\t\t${ shaderSobolCommon }\n\t\t\t\t${ shaderSobolSampling }\n\t\t\t\t${ shaderStructs }\n\t\t\t\t${ shaderIntersectFunction }\n\t\t\t\t${ shaderMaterialStructs }\n\t\t\t\t${ shaderLightStruct }\n\n\t\t\t\t${ shaderLayerTexelFetchFunctions }\n\t\t\t\t${ shaderUtils }\n\t\t\t\t${ shaderMaterialSampling }\n\t\t\t\t${ shaderEnvMapSampling }\n\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float environmentIntensity;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform LightsInfo lights;\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\n\t\t\t\t${ shaderLightSampling }\n\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + getHemisphereSample( direction, uv ) * 0.5 * backgroundBlur );\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\treturn sampleEquirectEnvMapColor( sampleDir, backgroundMap );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\treturn environmentIntensity * sampleEquirectEnvMapColor( sampleDir, envMapInfo.map );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t\t\t\tbool attenuateHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, int traversals, bool isShadowRay, out vec3 color ) {\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\tcolor = vec3( 1.0 );\n\n\t\t\t\t\t// TODO: we should be using sobol sampling here instead of rand but the sobol bounce and path indices need to be incremented\n\t\t\t\t\t// and then reset.\n\t\t\t\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\t\t\t\tif ( bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, barycoord, faceIndices.xyz );\n\n\t\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t\t// adjust the ray to the new surface\n\t\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Opacity Test\n\n\t\t\t\t\t\t\t// albedo\n\t\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// alphaMap\n\t\t\t\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transmission\n\t\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// metalness\n\t\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\t\t\tmaterial.side != 0.0 && side == material.side\n\n\t\t\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( side == 1.0 && isBelowSurface ) {\n\n\t\t\t\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t\t\t\t} else if ( side == - 1.0 ) {\n\n\t\t\t\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\t\t\t\tcolor *= transmissionAttenuation( dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// returns whether the ray hit anything before a certain distance, not just the first surface. Could be optimized to not check the full hierarchy.\n\t\t\t\tbool anyCloserHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, float maxDist ) {\n\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\t\t\t\treturn hit && dist < maxDist;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\t\t\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\t\t\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t\t\t\t}\n\n\t\t\t\tvoid getCameraRay( out vec3 rayDirection, out vec3 rayOrigin ) {\n\n\t\t\t\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t\t\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t\t\t\t// around this pixel's UV coordinate for AA\n\t\t\t\t\tvec2 ruv = sobol2( 0 );\n\t\t\t\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\n\t\t\t\t\t#if CAMERA_TYPE == 2\n\n\t\t\t\t\t\t// Equirectangular projection\n\t\t\t\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\t\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\t\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\t\t\t\trayDirection = normalize( rayDirection4.xyz );\n\t\t\t\t\t\trayOrigin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\t\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\t\t\t\trayOrigin = ndcToRayOrigin( ndc );\n\n\t\t\t\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t\t\t\t// Orthographic projection\n\t\t\t\t\t\t\trayDirection = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t// Perspective projection\n\t\t\t\t\t\t\trayDirection = normalize( mat3(cameraWorldMatrix) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if FEATURE_DOF\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// depth of field\n\t\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t\t\t\t// get the aperture sample\n\t\t\t\t\t\t// if blades === 0 then we assume a circle\n\t\t\t\t\t\tvec3 shapeUVW= sobol3( 1 );\n\t\t\t\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\t\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\t\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularNGon( blades, shapeUVW );\n\t\t\t\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t\t\t\t// rotate the aperture shape\n\t\t\t\t\t\tapertureSample =\n\t\t\t\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t\t\t\t// create the new ray\n\t\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\t\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | ( uint( gl_FragCoord.y ) );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\tvec3 rayDirection;\n\t\t\t\t\tvec3 rayOrigin;\n\n\t\t\t\t\tgetCameraRay( rayDirection, rayOrigin );\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tmat3 envRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tmat3 invEnvRotation3x3 = inverse( envRotation3x3 );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tfloat accumulatedClearcoatRoughness = 0.0;\n\t\t\t\t\tbool transmissiveRay = true;\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\t\t\t\t\tSampleRec sampleRec;\n\t\t\t\t\tint i;\n\t\t\t\t\tbool isShadowRay = false;\n\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t\tLightSampleRec lightHit = lightsClosestHit( lights.tex, lights.count, rayOrigin, rayDirection );\n\n\t\t\t\t\t\tif ( lightHit.hit && ( lightHit.dist < dist || !hit ) ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// NOTE: we skip MIS for punctual lights since they are not supported in forward PT case\n\t\t\t\t\t\t\t\tif ( lightHit.type == SPOT_LIGHT_TYPE || lightHit.type == DIR_LIGHT_TYPE || lightHit.type == POINT_LIGHT_TYPE ) {\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, lightHit.pdf / float( lights.count + 1u ) );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! hit ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( envRotation3x3 * rayDirection, sobol2( 2 ) ) * throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEnvMap( envMapInfo, envRotation3x3 * rayDirection, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= float( lights.count + 1u );\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectEnvMapColor( envRotation3x3 * rayDirection, envMapInfo.map ) *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\tif ( material.matte && i == 0 ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// uv coord for textures\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, barycoord, faceIndices.xyz );\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// alphaMap\n\t\t\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t\t\t\t\t// and it's single sided.\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\tmaterial.side != 0.0 && side != material.side\n\n\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < sobol( 3 )\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fetch the interpolated smooth normal\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tattributesArray,\n\t\t\t\t\t\t\tATTR_NORMAL,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\t// roughness\n\t\t\t\t\t\tfloat roughness = material.roughness;\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// metalness\n\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transmission\n\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.flatShading ) {\n\n\t\t\t\t\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t\t\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t\t\t\t\t// interpolated vertex normals.\n\t\t\t\t\t\t\tnormal = faceNormal * side;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec3 baseNormal = normal;\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\tattributesArray,\n\t\t\t\t\t\t\t\tATTR_TANGENT,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n\t\t\t\t\t\t// clearcoat\n\t\t\t\t\t\tfloat clearcoat = material.clearcoat;\n\t\t\t\t\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// clearcoatRoughness\n\t\t\t\t\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\t\t\t\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// clearcoatNormal\n\t\t\t\t\t\tvec3 clearcoatNormal = baseNormal;\n\t\t\t\t\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\tattributesArray,\n\t\t\t\t\t\t\t\tATTR_TANGENT,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\t\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclearcoatNormal *= side;\n\n\t\t\t\t\t\t// sheenColor\n\t\t\t\t\t\tvec3 sheenColor = material.sheenColor;\n\t\t\t\t\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sheenRoughness\n\t\t\t\t\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\t\t\t\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// iridescence\n\t\t\t\t\t\tfloat iridescence = material.iridescence;\n\t\t\t\t\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// iridescence thickness\n\t\t\t\t\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\t\t\t\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\t\t\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t\t\t\t\t// specular color\n\t\t\t\t\t\tvec3 specularColor = material.specularColor;\n\t\t\t\t\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// specular intensity\n\t\t\t\t\t\tfloat specularIntensity = material.specularIntensity;\n\t\t\t\t\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRec surfaceRec;\n\t\t\t\t\t\tsurfaceRec.normal = normal;\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\n\t\t\t\t\t\tsurfaceRec.emission = emission;\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\n\t\t\t\t\t\tsurfaceRec.clearcoat = clearcoat;\n\t\t\t\t\t\tsurfaceRec.sheenColor = sheenColor;\n\t\t\t\t\t\tsurfaceRec.iridescence = iridescence;\n\t\t\t\t\t\tsurfaceRec.iridescenceIor = material.iridescenceIor;\n\t\t\t\t\t\tsurfaceRec.iridescenceThickness = iridescenceThickness;\n\t\t\t\t\t\tsurfaceRec.specularColor = specularColor;\n\t\t\t\t\t\tsurfaceRec.specularIntensity = specularIntensity;\n\t\t\t\t\t\tsurfaceRec.attenuationColor = material.attenuationColor;\n\t\t\t\t\t\tsurfaceRec.attenuationDistance = material.attenuationDistance;\n\n\t\t\t\t\t\t// apply perceptual roughness factor from gltf\n\t\t\t\t\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\t\t\t\t\tsurfaceRec.roughness = roughness * roughness;\n\t\t\t\t\t\tsurfaceRec.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\t\t\t\t\tsurfaceRec.sheenRoughness = sheenRoughness * sheenRoughness;\n\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t\t\t\t\t// then we can just always assume this is a front face.\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\n\t\t\t\t\t\tsurfaceRec.eta = material.thinFilm || surfaceRec.frontFace ? 1.0 / material.ior : material.ior;\n\t\t\t\t\t\tsurfaceRec.f0 = iorRatioToF0( surfaceRec.eta );\n\t\t\t\t\t\tsurfaceRec.thinFilm = material.thinFilm;\n\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t\t\t\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t\t\t\t\t// sharp internal reflections\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = applyFilteredGlossy( surfaceRec.roughness, accumulatedRoughness );\n\t\t\t\t\t\tsurfaceRec.filteredClearcoatRoughness = applyFilteredGlossy( surfaceRec.clearcoatRoughness, accumulatedClearcoatRoughness );\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tmat3 clearcoatNormalBasis = getBasisFromNormal( clearcoatNormal );\n\t\t\t\t\t\tmat3 clearcoatInvBasis = inverse( clearcoatNormalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tvec3 clearcoatOutgoing = - normalize( clearcoatInvBasis * rayDirection );\n\t\t\t\t\t\tsampleRec = bsdfSample( outgoing, clearcoatOutgoing, normalBasis, invBasis, clearcoatNormalBasis, clearcoatInvBasis, surfaceRec );\n\n\t\t\t\t\t\tisShadowRay = sampleRec.specularPdf < sobol( 4 );\n\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\n\t\t\t\t\t\t// error as values increase.\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t// direct env map sampling\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t// uniformly pick a light or environment map\n\t\t\t\t\t\tif( sobol( 5 ) > 1.0 / float( lights.count + 1u ) ) {\n\n\t\t\t\t\t\t\t// sample a light or environment\n\t\t\t\t\t\t\tLightSampleRec lightSampleRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, sobol3( 6 ) );\n\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, lightSampleRec.direction ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tlightSampleRec.pdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the light area\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlightSampleRec.pdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( lightSampleRec.direction, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! anyCloserHit( bvh, rayOrigin, lightSampleRec.direction, lightSampleRec.dist )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat lightMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * lightSampleRec.direction ), normalize( clearcoatInvBasis * lightSampleRec.direction ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tfloat lightPdf = lightSampleRec.pdf / float( lights.count + 1u );\n\t\t\t\t\t\t\t\t\tfloat misWeight = lightSampleRec.type == SPOT_LIGHT_TYPE || lightSampleRec.type == DIR_LIGHT_TYPE || lightSampleRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\t\t\t\t\tvec3 envColor, envDirection;\n\t\t\t\t\t\t\tfloat envPdf = sampleEnvMapProbability( envMapInfo, sobol2( 7 ), envColor, envDirection );\n\t\t\t\t\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t\t\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t\t\t\t\t// results so we ignore the sample in this case.\n\t\t\t\t\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, envDirection ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tenvPdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the surface\n\t\t\t\t\t\t\tvec3 attenuatedColor;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( envDirection, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, envDirection, bounces - i, isShadowRay, attenuatedColor )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat envMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * envDirection ), normalize( clearcoatInvBasis * envDirection ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tenvPdf /= float( lights.count + 1u );\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acosApprox( halfVector.z ) );\n\n\t\t\t\t\t\t\tvec3 clearcoatHalfVector = normalize( clearcoatOutgoing + sampleRec.clearcoatDirection );\n\t\t\t\t\t\t\taccumulatedClearcoatRoughness += sin( acosApprox( clearcoatHalfVector.z ) );\n\n\t\t\t\t\t\t\ttransmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( side == - 1.0 ) {\n\n\t\t\t\t\t\t\tthroughputColor *= transmissionAttenuation( dist, surfaceRec.attenuationColor, surfaceRec.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide } from 'three';\nimport { reduceTexturesToUniqueSources, getTextureHash } from './utils.js';\n\nconst MATERIAL_PIXELS = 45;\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\n\nconst MATTE_OFFSET = 14 * 4 + 0; // s14.r\nconst SHADOW_OFFSET = 14 * 4 + 1; // s14.g\n\nexport class MaterialsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.generateMipmaps = false;\n\t\tthis.threeCompatibilityTransforms = false;\n\n\t}\n\n\tsetCastShadow( materialIndex, cast ) {\n\n\t\t// invert the shadow value so we default to \"true\" when initializing a material\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + SHADOW_OFFSET;\n\t\tarray[ index ] = ! cast ? 1 : 0;\n\n\t}\n\n\tgetCastShadow( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + SHADOW_OFFSET;\n\t\treturn ! Boolean( array[ index ] );\n\n\t}\n\n\tsetMatte( materialIndex, matte ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + MATTE_OFFSET;\n\t\tarray[ index ] = matte ? 1 : 0;\n\n\t}\n\n\tgetMatte( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + MATTE_OFFSET;\n\t\treturn Boolean( array[ index ] );\n\n\t}\n\n\tupdateFrom( materials, textures ) {\n\n\t\tfunction getTexture( material, key, def = - 1 ) {\n\n\t\t\tif ( key in material && material[ key ] ) {\n\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\n\t\t\t\treturn uniqueTextureLookup[ hash ];\n\n\t\t\t} else {\n\n\t\t\t\treturn def;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getField( material, key, def ) {\n\n\t\t\treturn key in material ? material[ key ] : def;\n\n\t\t}\n\n\t\tfunction getUVTransformTexture( material ) {\n\n\t\t\t// https://github.com/mrdoob/three.js/blob/f3a832e637c98a404c64dae8174625958455e038/src/renderers/webgl/WebGLMaterials.js#L204-L306\n\t\t\t// https://threejs.org/docs/#api/en/textures/Texture.offset\n\t\t\t// fallback order of textures to use as a common uv transform\n\t\t\treturn material.map ||\n\t\t\t\tmaterial.specularMap ||\n\t\t\t\tmaterial.displacementMap ||\n\t\t\t\tmaterial.normalMap ||\n\t\t\t\tmaterial.bumpMap ||\n\t\t\t\tmaterial.roughnessMap ||\n\t\t\t\tmaterial.metalnessMap ||\n\t\t\t\tmaterial.alphaMap ||\n\t\t\t\tmaterial.emissiveMap ||\n\t\t\t\tmaterial.clearcoatMap ||\n\t\t\t\tmaterial.clearcoatNormalMap ||\n\t\t\t\tmaterial.clearcoatRoughnessMap ||\n\t\t\t\tmaterial.iridescenceMap ||\n\t\t\t\tmaterial.iridescenceThicknessMap ||\n\t\t\t\tmaterial.specularIntensityMap ||\n\t\t\t\tmaterial.specularColorMap ||\n\t\t\t\tmaterial.transmissionMap ||\n\t\t\t\tmaterial.thicknessMap ||\n\t\t\t\tmaterial.sheenColorMap ||\n\t\t\t\tmaterial.sheenRoughnessMap ||\n\t\t\t\tnull;\n\n\t\t}\n\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\n\n\t\t\tlet texture;\n\t\t\tif ( threeCompatibilityTransforms ) {\n\n\t\t\t\ttexture = getUVTransformTexture( material );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\n\n\t\t\t}\n\n\t\t\t// check if texture exists\n\t\t\tif ( texture ) {\n\n\t\t\t\tconst elements = texture.matrix.elements;\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\t// first row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\n\t\t\t\ti ++;\n\n\t\t\t\t// second row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn 8;\n\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\t\tconst { threeCompatibilityTransforms, image } = this;\n\n\t\t// get the list of textures with unique sources\n\t\tconst uniqueTextures = reduceTexturesToUniqueSources( textures );\n\t\tconst uniqueTextureLookup = {};\n\t\tfor ( let i = 0, l = uniqueTextures.length; i < l; i ++ ) {\n\n\t\t\tuniqueTextureLookup[ getTextureHash( uniqueTextures[ i ] ) ] = i;\n\n\t\t}\n\n\t\tif ( image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\n\t\t\timage.width = dimension;\n\t\t\timage.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = image.data;\n\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n\t\t// can't encode texture ids that way.\n\t\t// const intArray = new Int32Array( floatArray.buffer );\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tconst m = materials[ i ];\n\n\t\t\t// sample 0\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = m.color.r;\n\t\t\tfloatArray[ index ++ ] = m.color.g;\n\t\t\tfloatArray[ index ++ ] = m.color.b;\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\n\n\t\t\t// sample 1\n\t\t\t// metalness & roughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\n\n\t\t\t// sample 2\n\t\t\t// transmission & emissiveIntensity\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t// sample 3\n\t\t\t// emission\n\t\t\tif ( 'emissive' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\n\n\t\t\t// sample 4\n\t\t\t// normals\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\n\t\t\tif ( 'normalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\n\n \t\t\t} else {\n\n \t\t\t\tfloatArray[ index ++ ] = 1;\n \t\t\t\tfloatArray[ index ++ ] = 1;\n\n \t\t\t}\n\n\t\t\t// clearcoat\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\n\n\t\t\t// sample 6\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\n\t\t\t}\n\n\t\t\tindex ++;\n\t\t\tindex ++;\n\n\t\t\t// sample 7\n\t\t\t// sheen\n\t\t\tif ( 'sheenColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\n\n\t\t\t// sample 8\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\n\n\t\t\t// iridescence\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 ); // sample 9\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\n\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\n\n\t\t\t// sample 10\n\t\t\t// specular color\n\t\t\tif ( 'specularColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\n\n\t\t\t// sample 11\n\t\t\t// specular intensity\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\n\n\t\t\t// isThinFilm\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\n\t\t\tindex ++;\n\n\t\t\t// sample 12\n\t\t\tif ( 'attenuationColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\n\n\t\t\t// sample 13\n\t\t\t// alphaMap\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\n\n\t\t\t// side & matte\n\t\t\tfloatArray[ index ++ ] = m.opacity;\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\n\n\t\t\t\tfloatArray[ index ++ ] = 0;\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( m.side ) {\n\n\t\t\t\tcase FrontSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BackSide:\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DoubleSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sample 14\n\t\t\tindex ++; // matte\n\t\t\tindex ++; // shadow\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ); // vertexColors & flatShading\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\n\n\t\t\t// map transform 15\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\n\n\t\t\t// metalnessMap transform 17\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\n\n\t\t\t// roughnessMap transform 19\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\n\n\t\t\t// transmissionMap transform 21\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\n\n\t\t\t// emissiveMap transform 22\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\n\n\t\t\t// normalMap transform 25\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\n\n\t\t\t// clearcoatMap transform 27\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\n\n\t\t\t// clearcoatNormalMap transform 29\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\n\n\t\t\t// clearcoatRoughnessMap transform 31\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\n\n\t\t\t// sheenColorMap transform 33\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\n\n\t\t\t// sheenRoughnessMap transform 35\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\n\n\t\t\t// iridescenceMap transform 37\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\n\n\t\t\t// iridescenceThicknessMap transform 39\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\n\n\t\t\t// specularColorMap transform 41\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\n\n\t\t\t// specularIntensityMap transform 43\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n","// we must hash the texture to determine uniqueness using the encoding, as well, because the\n// when rendering each texture to the texture array they must have a consistent color space.\nexport function getTextureHash( t ) {\n\n\treturn `${ t.source.uuid }:${ t.encoding }`;\n\n}\n\n// reduce the set of textures to just those with a unique source while retaining\n// the order of the textures.\nexport function reduceTexturesToUniqueSources( textures ) {\n\n\tconst sourceSet = new Set();\n\tconst result = [];\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\tconst tex = textures[ i ];\n\t\tconst hash = getTextureHash( tex );\n\t\tif ( ! sourceSet.has( hash ) ) {\n\n\t\t\tsourceSet.add( hash );\n\t\t\tresult.push( tex );\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n","import {\n\tWebGLArrayRenderTarget,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tMeshBasicMaterial,\n\tColor,\n\tRepeatWrapping,\n\tLinearFilter,\n\tNoToneMapping,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { reduceTexturesToUniqueSources } from './utils.js';\n\nconst prevColor = new Color();\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = UnsignedByteType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = RepeatWrapping;\n\t\ttex.wrapT = RepeatWrapping;\n\t\ttex.setTextures = ( ...args ) => {\n\n\t\t\tthis.setTextures( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t}\n\n\tsetTextures( renderer, width, height, textures ) {\n\n\t\t// get the list of textures with unique sources\n\t\tconst uniqueTextures = reduceTexturesToUniqueSources( textures );\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\n\t\tconst depth = uniqueTextures.length || 1;\n\t\tthis.setSize( width, height, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = uniqueTextures[ i ];\n\t\t\tif ( texture ) {\n\n\t\t\t\t// revert to default texture transform before rendering\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t\ttexture.matrix.identity();\n\n\t\t\t\tfsQuad.material.map = texture;\n\t\t\t\tfsQuad.material.transparent = true;\n\n\t\t\t\trenderer.setRenderTarget( this, i );\n\t\t\t\tfsQuad.render( renderer );\n\n\t\t\t\t// restore custom texture transform\n\t\t\t\ttexture.updateMatrix();\n\t\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n","import { shaderGGXFunctions } from './shaderGGXFunctions.js';\nimport { shaderSheenFunctions } from './shaderSheenFunctions.js';\nimport { shaderIridescenceFunctions } from './shaderIridescenceFunctions.js';\n\n/*\nwi     : incident vector or light vector (pointing toward the light)\nwo     : outgoing vector or view vector (pointing towards the camera)\nwh     : computed half vector from wo and wi\nEval   : Get the color and pdf for a direction\nSample : Get the direction, color, and pdf for a sample\neta    : Greek character used to denote the \"ratio of ior\"\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\n*/\n\nexport const shaderMaterialSampling = /* glsl */`\n\nstruct SurfaceRec {\n\tvec3 normal;\n\tvec3 faceNormal;\n\tbool frontFace;\n\tfloat roughness;\n\tfloat filteredRoughness;\n\tfloat metalness;\n\tvec3 color;\n\tvec3 emission;\n\tfloat transmission;\n\tbool thinFilm;\n\tfloat ior;\n\tfloat eta;\n\tfloat f0;\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n\tfloat filteredClearcoatRoughness;\n\tvec3 sheenColor;\n\tfloat sheenRoughness;\n\tfloat iridescence;\n\tfloat iridescenceIor;\n\tfloat iridescenceThickness;\n\tvec3 specularColor;\n\tfloat specularIntensity;\n\tvec3 attenuationColor;\n\tfloat attenuationDistance;\n};\n\nstruct SampleRec {\n\tfloat specularPdf;\n\tfloat pdf;\n\tvec3 direction;\n\tvec3 clearcoatDirection;\n\tvec3 color;\n};\n\n${ shaderGGXFunctions }\n${ shaderSheenFunctions }\n${ shaderIridescenceFunctions }\n\nfloat disneyFresnel( SurfaceRec surf, vec3 wo, vec3 wi, vec3 wh ) {\n\n\tfloat dotHV = dot( wo, wh );\n\tfloat dotHL = dot( wi, wh );\n\n\t// TODO: some model-viewer test models look better when surf.eta is set to a non 1.5 eta here here?\n\t// and the furnace test seems to pass when it === 1.0\n\t// float dielectricFresnel = dielectricFresnel( abs( dotHV ), surf.eta );\n\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), 1.0 / 1.1 );\n\tfloat metallicFresnel = schlickFresnel( dotHL, surf.f0 );\n\n\treturn mix( dielectricFresnel, metallicFresnel, surf.metalness );\n\n}\n\n// diffuse\nfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRec surf, out vec3 color ) {\n\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\tfloat metalFactor = ( 1.0 - surf.metalness );\n\tfloat transFactor = ( 1.0 - surf.transmission );\n\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t// TODO: subsurface approx?\n\n\tfloat FM = disneyFresnel( surf, wo, wi, wh );\n\n\tcolor = ( 1.0 - FM ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\treturn wi.z / PI;\n\n}\n\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\n\n\tvec3 lightDirection = sampleSphere( sobol2( 11 ) );\n\tlightDirection.z += 1.0;\n\tlightDirection = normalize( lightDirection );\n\n\treturn lightDirection;\n\n}\n\n// specular\nfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRec surf, out vec3 color ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tfloat metalness = surf.metalness;\n\tfloat filteredRoughness = surf.filteredRoughness;\n\n\tfloat eta = surf.eta;\n\tfloat f0 = surf.f0;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tfloat D = ggxDistribution( wh, filteredRoughness );\n\tfloat FM = disneyFresnel( surf, wo, wi, wh );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = eta * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tFM = 1.0;\n\n\t}\n\n\tvec3 metalColor = surf.color;\n\tvec3 dielectricColor = f0 * surf.specularColor;\n\tvec3 specColor = mix( dielectricColor, metalColor, surf.metalness );\n\n\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, vec3( f0 ) );\n\tvec3 iridescenceMix = mix( vec3( FM ), iridescenceF, surf.iridescence );\n\tvec3 F = mix( specColor, vec3( 1.0 ), iridescenceMix );\n\n\tcolor = mix( surf.specularIntensity, 1.0, surf.metalness ) * wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\n\t// PDF\n\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\tfloat incidentTheta = acos( wo.z );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, filteredRoughness );\n\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n}\n\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tvec2( filteredRoughness ),\n\t\tsobol2( 12 )\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\n\n// transmission\n/*\nfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRec surf, out vec3 color ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tfloat eta = surf.eta;\n\tbool frontFace = surf.frontFace;\n\tbool thinFilm = surf.thinFilm;\n\n\tvec3 col = thinFilm || frontFace ? surf.color : vec3( 1.0 );\n\tcolor = surf.transmission * col;\n\n\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tfloat eta = surf.eta;\n\tbool frontFace = surf.frontFace;\n\n\t// sample ggx vndf distribution which gives a new normal\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tvec2( filteredRoughness ),\n\t\tsobol2( 13 )\n\t);\n\n\n\t// TODO: support thin film\n\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\treturn normalize( lightDirection );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRec surf, out vec3 color ) {\n\n\t// only attenuate the color if it's on the way in\n\tvec3 col = surf.thinFilm || surf.frontFace ? surf.color : vec3( 1.0 );\n\tcolor = surf.transmission * col;\n\n\t// PDF\n\tfloat eta = surf.eta;\n\tfloat f0 = surf.f0;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnel( cosTheta, f0 );\n\tbool cannotRefract = eta * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat roughness = surf.roughness;\n\tfloat eta = surf.eta;\n\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( sobol2( 13 ) ) * roughness );\n\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\tif ( surf.thinFilm ) {\n\n\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t}\n\treturn normalize( lightDirection );\n\n}\n\n// clearcoat\nfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRec surf, inout vec3 color ) {\n\n\tfloat ior = 1.5;\n\tfloat f0 = iorRatioToF0( ior );\n\tbool frontFace = surf.frontFace;\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\n\tfloat eta = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredClearcoatRoughness );\n\tfloat D = ggxDistribution( wh, filteredClearcoatRoughness );\n\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = eta * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t// PDF\n\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\treturn ggxPDF( wo, wh, filteredClearcoatRoughness ) / ( 4.0 * dot( wi, wh ) );\n\n}\n\nvec3 clearcoatDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tvec2( filteredClearcoatRoughness ),\n\t\tsobol2( 14 )\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\n// sheen\nvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRec surf ) {\n\n\tfloat cosThetaO = saturateCos( wo.z );\n\tfloat cosThetaI = saturateCos( wi.z );\n\tfloat cosThetaH = wh.z;\n\n\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tvec3 color = surf.sheenColor;\n\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\tcolor *= wi.z;\n\n\treturn color;\n\n}\n\n// bsdf\nvoid getLobeWeights(\n\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRec surf,\n\tout float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight\n) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tfloat eta = surf.eta;\n\tfloat f0 = surf.f0;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n\t// TODO: does \"cannot refract\" belong in disney fresnel?\n\tfloat reflectance = disneyFresnel( surf, wo, wi, wh );\n\tbool cannotRefract = eta * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat transSpecularProb = mix( max( 0.25, reflectance ), 1.0, metalness );\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\tdiffuseWeight /= totalWeight;\n\tspecularWeight /= totalWeight;\n\ttransmissionWeight /= totalWeight;\n\tclearcoatWeight /= totalWeight;\n}\n\nfloat bsdfEval(\n\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf,\n\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, out float specularPdf, out vec3 color\n) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tfloat eta = surf.eta;\n\tfloat f0 = surf.f0;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnel( cosTheta, f0 );\n\tbool cannotRefract = eta * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat spdf = 0.0;\n\tfloat dpdf = 0.0;\n\tfloat tpdf = 0.0;\n\tfloat cpdf = 0.0;\n\tcolor = vec3( 0.0 );\n\n\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t// diffuse\n\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\tcolor *= 1.0 - surf.transmission;\n\n\t}\n\n\t// ggx specular\n\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\tvec3 outColor;\n\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\tcolor += outColor;\n\n\t}\n\n\t// transmission\n\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t}\n\n\t// sheen\n\tcolor *= sheenAlbedoScaling( wo, wi, surf );\n\tcolor += sheenColor( wo, wi, halfVector, surf );\n\n\t// clearcoat\n\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t}\n\n\tfloat pdf =\n\t\t  dpdf * diffuseWeight\n\t\t+ spdf * specularWeight\n\t\t+ tpdf * transmissionWeight\n\t\t+ cpdf * clearcoatWeight;\n\n\t// retrieve specular rays for the shadows flag\n\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\treturn pdf;\n\n}\n\nfloat bsdfResult( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, out vec3 color ) {\n\n\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\tfloat diffuseWeight;\n\tfloat specularWeight;\n\tfloat transmissionWeight;\n\tfloat clearcoatWeight;\n\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\tfloat specularPdf;\n\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n}\n\nSampleRec bsdfSample( vec3 wo, vec3 clearcoatWo, mat3 normalBasis, mat3 invBasis, mat3 clearcoatNormalBasis, mat3 clearcoatInvBasis, SurfaceRec surf ) {\n\n\tfloat diffuseWeight;\n\tfloat specularWeight;\n\tfloat transmissionWeight;\n\tfloat clearcoatWeight;\n\t// using normal and basically-reflected ray since we don't have proper half vector here\n\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\tfloat pdf[4];\n\tpdf[0] = diffuseWeight;\n\tpdf[1] = specularWeight;\n\tpdf[2] = transmissionWeight;\n\tpdf[3] = clearcoatWeight;\n\n\tfloat cdf[4];\n\tcdf[0] = pdf[0];\n\tcdf[1] = pdf[1] + cdf[0];\n\tcdf[2] = pdf[2] + cdf[1];\n\tcdf[3] = pdf[3] + cdf[2];\n\n\tif( cdf[3] != 0.0 ) {\n\n\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\tcdf[0] *= invMaxCdf;\n\t\tcdf[1] *= invMaxCdf;\n\t\tcdf[2] *= invMaxCdf;\n\t\tcdf[3] *= invMaxCdf;\n\n\t} else {\n\n\t\tcdf[0] = 1.0;\n\t\tcdf[1] = 0.0;\n\t\tcdf[2] = 0.0;\n\t\tcdf[3] = 0.0;\n\n\t}\n\n\tvec3 wi;\n\tvec3 clearcoatWi;\n\n\tfloat r = sobol( 15 );\n\tif ( r <= cdf[0] ) { // diffuse\n\n\t\twi = diffuseDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[1] ) { // specular\n\n\t\twi = specularDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\twi = transmissionDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t}\n\n\tSampleRec result;\n\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\tresult.direction = wi;\n\tresult.clearcoatDirection = clearcoatWi;\n\n\treturn result;\n\n}\n`;\n","export const shaderGGXFunctions = /* glsl */`\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\n// trowbridge-reitz === GGX === GTR\n\nvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t// orthonormal basis\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 T2 = cross( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / ( 1.0 + V.z );\n\tfloat r = sqrt( uv.x );\n\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\tfloat P1 = r * cos( phi );\n\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t// unstretch\n\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\treturn N;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (34) from reference [0]\nfloat ggxLamda( float theta, float roughness ) {\n\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = tanTheta * tanTheta;\n\tfloat alpha2 = roughness * roughness;\n\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\treturn numerator / 2.0;\n\n}\n\n// See equation (34) from reference [0]\nfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat scatterTheta = acos( wo.z );\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\n// See equation (33) from reference [0]\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\tfloat a2 = roughness * roughness;\n\ta2 = max( EPSILON, a2 );\n\tfloat cosTheta = halfVector.z;\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\tif ( cosTheta == 0.0 ) return 0.0;\n\n\tfloat theta = acosSafe( halfVector.z );\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\treturn ( a2 / denom );\n\n}\n\n// See equation (3) from reference [2]\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat D = ggxDistribution( halfVector, roughness );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n}\n`;\n","export const shaderSheenFunctions = /* glsl */`\n\n// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat velvetD( float cosThetaH, float roughness ) {\n\n\tfloat alpha = max( roughness, 0.07 );\n\talpha = alpha * alpha;\n\n\tfloat invAlpha = 1.0 / alpha;\n\n\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n}\n\nfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n}\n\nfloat velvetL( float x, float alpha ) {\n\n\tfloat oneMinusAlpha = 1.0 - alpha;\n\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n}\n\n// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat velvetLambda( float cosTheta, float alpha ) {\n\n\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n}\n\n// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\tfloat alpha = max( roughness, 0.07 );\n\talpha = alpha * alpha;\n\n\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n}\n\nfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\tcosTheta = saturate( cosTheta );\n\n\tfloat c = 1.0 - cosTheta;\n\tfloat c3 = c * c * c;\n\n\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n}\n\nfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\talpha = alpha * alpha;\n\n\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n}\n\n// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat sheenAlbedoScaling( vec3 wo, SurfaceRec surf ) {\n\n\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\talpha = alpha * alpha;\n\n\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\treturn 1.0 - maxSheenColor * eWo;\n\n}\n\n`;\n","export const shaderIridescenceFunctions = /* glsl */`\n\n// XYZ to sRGB color space\nconst mat3 XYZ_TO_REC709 = mat3(\n\t 3.2404542, -0.9692660,  0.0556434,\n\t-1.5371385,  1.8760108, -0.2040259,\n\t-0.4985314,  0.0415560,  1.0572252\n);\n\nvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\tvec3 sqrtF0 = sqrt( fresnel0 );\n\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n}\n\n// Conversion FO/IOR\nvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n}\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n}\n\n// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\txyz /= 1.0685e-7;\n\n\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\treturn srgb;\n\n}\n\n// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\tvec3 I;\n\n\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t// Handle TIR:\n\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\treturn vec3( 1.0 );\n\n\t}\n\n\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t// First interface\n\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\tfloat R21 = R12;\n\tfloat T121 = 1.0 - R12;\n\tfloat phi12 = 0.0;\n\tif ( iridescenceIor < outsideIOR ) {\n\n\t\tphi12 = PI;\n\n\t}\n\tfloat phi21 = PI - phi12;\n\n\t// Second interface\n\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\tvec3 phi23 = vec3( 0.0 );\n\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\tphi23[ 0 ] = PI;\n\n\t}\n\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\tphi23[ 1 ] = PI;\n\n\t}\n\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\tphi23[ 2 ] = PI;\n\n\t}\n\n\t// Phase shift\n\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t// Compound terms\n\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\tvec3 r123 = sqrt( R123 );\n\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tvec3 C0 = R12 + Rs;\n\tI = C0;\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tvec3 Cm = Rs - T121;\n\tfor ( int m = 1; m <= 2; ++ m )\n\t{\n\t\tCm *= r123;\n\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\tI += Cm * Sm;\n\t}\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn max( I, vec3( 0.0 ) );\n}\n\n`;\n","export const shaderEnvMapSampling = /* glsl */`\n\nvec3 sampleEquirectEnvMapColor( vec3 direction, sampler2D map ) {\n\n\treturn texture2D( map, equirectDirectionToUv( direction ) ).rgb;\n\n}\n\nfloat envMapDirectionPdf( vec3 direction ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tfloat theta = uv.y * PI;\n\tfloat sinTheta = sin( theta );\n\tif ( sinTheta == 0.0 ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n}\n\nfloat sampleEnvMap( EquirectHdrInfo info, vec3 direction, out vec3 color ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = info.totalSumWhole + info.totalSumDecimal;\n\tfloat lum = luminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\nfloat sampleEnvMapProbability( EquirectHdrInfo info, vec2 r, out vec3 color, out vec3 direction ) {\n\n\t// sample env map cdf\n\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\tvec2 uv = vec2( u, v );\n\n\tvec3 derivedDirection = equirectUvToDirection( uv );\n\tdirection = derivedDirection;\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = info.totalSumWhole + info.totalSumDecimal;\n\tfloat lum = luminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\n`;\n","export const shaderLightSampling = /* glsl */`\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\tif ( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n}\n\nfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n    float cosTheta = dot( posToLight, lightDir );\n    float angle = acos( cosTheta ) * ( 1.0 / PI );\n\n    return texture2D( iesProfiles, vec3( 0.0, angle, iesProfile ) ).r;\n\n}\n\nstruct LightSampleRec {\n\n\tbool hit;\n\tfloat dist;\n\tvec3 direction;\n\tfloat pdf;\n\tvec3 emission;\n\tint type;\n\n};\n\nLightSampleRec lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection ) {\n\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = false;\n\n\tuint l;\n\tfor ( l = 0u; l < lightCount; l ++ ) {\n\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\n\t\t// check for backface\n\t\tvec3 normal = normalize( cross( u, v ) );\n\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tu *= 1.0 / dot( u, u );\n\t\tv *= 1.0 / dot( v, v );\n\n\t\tfloat dist;\n\n\t\t// MIS / light intersection is not supported for punctual lights.\n\t\tif(\n\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t) {\n\n\t\t\tif ( dist < lightSampleRec.dist || ! lightSampleRec.hit ) {\n\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\n\t\t\t\tlightSampleRec.hit = true;\n\t\t\t\tlightSampleRec.dist = dist;\n\t\t\t\tlightSampleRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\tlightSampleRec.emission = light.color * light.intensity;\n\t\t\t\tlightSampleRec.direction = rayDirection;\n\t\t\t\tlightSampleRec.type = light.type;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = true;\n\tlightSampleRec.type = light.type;\n\n\tlightSampleRec.emission = light.color * light.intensity;\n\n\tvec3 randomPos;\n\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t// rectangular area light\n\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t// circular area light\n\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\n\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t}\n\n\tvec3 toLight = randomPos - rayOrigin;\n\tfloat lightDistSq = dot( toLight, toLight );\n\tlightSampleRec.dist = sqrt( lightDistSq );\n\n\tvec3 direction = toLight / lightSampleRec.dist;\n\tlightSampleRec.direction = direction;\n\n\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\tlightSampleRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\tfloat radius = light.radius * sqrt( ruv.x );\n\tfloat theta = ruv.y * 2.0 * PI;\n\tfloat x = radius * cos( theta );\n\tfloat y = radius * sin( theta );\n\n\tvec3 u = light.u;\n\tvec3 v = light.v;\n\tvec3 normal = normalize( cross( u, v ) );\n\n\tfloat angle = acos( light.coneCos );\n\tfloat angleTan = tan( angle );\n\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\tvec3 toLight = randomPos - rayOrigin;\n\tfloat lightDistSq = dot( toLight, toLight );\n\tfloat dist = sqrt( lightDistSq );\n\n\tvec3 direction = toLight / max( dist, EPSILON );\n\tfloat cosTheta = dot( direction, normal );\n\n\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = true;\n\tlightSampleRec.type = light.type;\n\tlightSampleRec.dist = dist;\n\tlightSampleRec.direction = direction;\n\tlightSampleRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\tlightSampleRec.pdf = 1.0;\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t// pick a random light\n\tuint l = uint( ruv.x * float( lightCount ) );\n\tLight light = readLightInfo( lights, l );\n\n\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\treturn randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\tvec3 lightRay = light.u - rayOrigin;\n\t\tfloat lightDist = length( lightRay );\n\t\tfloat cutoffDistance = light.distance;\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t}\n\n\t\tLightSampleRec rec;\n\t\trec.hit = true;\n\t\trec.direction = normalize( lightRay );\n\t\trec.dist = length( lightRay );\n\t\trec.pdf = 1.0;\n\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\trec.type = light.type;\n\t\treturn rec;\n\n\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\tLightSampleRec rec;\n\t\trec.hit = true;\n\t\trec.dist = 1e10;\n\t\trec.direction = light.u;\n\t\trec.pdf = 1.0;\n\t\trec.emission = light.color * light.intensity;\n\t\trec.type = light.type;\n\n\t\treturn rec;\n\n\t} else {\n\n\t\t// sample the light\n\t\treturn randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t}\n\n}\n\n`;\n","\nexport const shaderLayerTexelFetchFunctions = /*glsl */`\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n`;\n","import { PhysicalCamera } from '../objects/PhysicalCamera.js';\nexport class PhysicalCameraUniform {\n\n\tconstructor() {\n\n\t\tthis.bokehSize = 0;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 10;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tupdateFrom( camera ) {\n\n\t\tif ( camera instanceof PhysicalCamera ) {\n\n\t\t\tthis.bokehSize = camera.bokehSize;\n\t\t\tthis.apertureBlades = camera.apertureBlades;\n\t\t\tthis.apertureRotation = camera.apertureRotation;\n\t\t\tthis.focusDistance = camera.focusDistance;\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\n\n\t\t} else {\n\n\t\t\tthis.bokehSize = 0;\n\t\t\tthis.apertureRotation = 0;\n\t\t\tthis.apertureBlades = 0;\n\t\t\tthis.focusDistance = 10;\n\t\t\tthis.anamorphicRatio = 1;\n\n\t\t}\n\n\t}\n\n}\n","import { DataTexture, FloatType, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping } from 'three';\n\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\n\n\tlet lower = 0;\n\tlet upper = count - 1;\n\twhile ( lower < upper ) {\n\n\t\tconst mid = ~ ~ ( 0.5 * upper + 0.5 * lower );\n\n\t\t// check if the middle array value is above or below the target and shift\n\t\t// which half of the array we're looking at\n\t\tif ( array[ offset + mid ] < targetValue ) {\n\n\t\t\tlower = mid + 1;\n\n\t\t} else {\n\n\t\t\tupper = mid;\n\n\t\t}\n\n\t}\n\n\treturn lower;\n\n}\n\nfunction colorToLuminance( r, g, b ) {\n\n\t// https://en.wikipedia.org/wiki/Relative_luminance\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\n}\n\n// ensures the data is all floating point values and flipY is false\nfunction preprocessEnvMap( envMap ) {\n\n\tconst map = envMap.clone();\n\tmap.source = new Source( { ...map.image } );\n\tconst { width, height, data } = map.image;\n\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\n\tlet newData = data;\n\tif ( map.type === HalfFloatType ) {\n\n\t\tnewData = new Float32Array( data.length );\n\t\tfor ( const i in data ) {\n\n\t\t\tnewData[ i ] = DataUtils.fromHalfFloat( data[ i ] );\n\n\t\t}\n\n\t\tmap.image.data = newData;\n\t\tmap.type = FloatType;\n\n\t}\n\n\t// remove any y flipping for cdf computation\n\tif ( map.flipY ) {\n\n\t\tconst ogData = newData;\n\t\tnewData = newData.slice();\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst newY = height - y - 1;\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\n\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.flipY = false;\n\t\tmap.image.data = newData;\n\n\t}\n\n\treturn map;\n\n}\n\nexport class EquirectHdrInfoUniform {\n\n\tconstructor() {\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\n\t\t// used to sampling a random value to a relevant row to sample from\n\t\tconst marginalWeights = new DataTexture();\n\t\tmarginalWeights.type = FloatType;\n\t\tmarginalWeights.format = RedFormat;\n\t\tmarginalWeights.minFilter = LinearFilter;\n\t\tmarginalWeights.magFilter = LinearFilter;\n\t\tmarginalWeights.generateMipmaps = false;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\n\t\t// used to sampling a random value to a relevant pixel to sample from\n\t\tconst conditionalWeights = new DataTexture();\n\t\tconditionalWeights.type = FloatType;\n\t\tconditionalWeights.format = RedFormat;\n\t\tconditionalWeights.minFilter = LinearFilter;\n\t\tconditionalWeights.magFilter = LinearFilter;\n\t\tconditionalWeights.generateMipmaps = false;\n\n\t\tthis.marginalWeights = marginalWeights;\n\t\tthis.conditionalWeights = conditionalWeights;\n\t\tthis.map = null;\n\n\t\t// the total sum value is separated into two values to work around low precision\n\t\t// storage of floating values in structs\n\t\tthis.totalSumWhole = 0;\n\t\tthis.totalSumDecimal = 0;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.marginalWeights.dispose();\n\t\tthis.conditionalWeights.dispose();\n\t\tif ( this.map ) this.map.dispose();\n\n\t}\n\n\tupdateFrom( hdr ) {\n\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\n\t\tconst map = preprocessEnvMap( hdr );\n\t\tmap.wrapS = RepeatWrapping;\n\t\tmap.wrapT = RepeatWrapping;\n\n\t\tconst { width, height, data } = map.image;\n\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\n\t\t// \"marginal\" = \"row relative to row sum\"\n\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\n\t\tconst pdfConditional = new Float32Array( width * height );\n\t\tconst cdfConditional = new Float32Array( width * height );\n\n\t\tconst pdfMarginal = new Float32Array( height );\n\t\tconst cdfMarginal = new Float32Array( height );\n\n\t\tlet totalSumValue = 0.0;\n\t\tlet cumulativeWeightMarginal = 0.0;\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tlet cumulativeRowWeight = 0.0;\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst r = data[ 4 * i + 0 ];\n\t\t\t\tconst g = data[ 4 * i + 1 ];\n\t\t\t\tconst b = data[ 4 * i + 2 ];\n\n\t\t\t\t// the probability of the pixel being selected in this row is the\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\n\t\t\t\tcumulativeRowWeight += weight;\n\t\t\t\ttotalSumValue += weight;\n\n\t\t\t\tpdfConditional[ i ] = weight;\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\n\n\t\t\t}\n\n\t\t\t// can happen if the row is all black\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\n\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\n\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\n\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\n\n\t\t}\n\n\t\t// can happen if the texture is all black\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\n\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\n\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute a sorted index of distributions and the probabilities along them for both\n\t\t// the marginal and conditional data. These will be used to sample with a random number\n\t\t// to retrieve a uv value to sample in the environment map.\n\t\t// These values continually increase so it's okay to interpolate between them.\n\t\tconst marginalDataArray = new Float32Array( height );\n\t\tconst conditionalDataArray = new Float32Array( width * height );\n\n\t\t// we add a half texel offset so we're sampling the center of the pixel\n\t\tfor ( let i = 0; i < height; i ++ ) {\n\n\t\t\tconst dist = ( i + 1 ) / height;\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\n\n\t\t\tmarginalDataArray[ i ] = ( row + 0.5 ) / height;\n\n\t\t}\n\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst dist = ( x + 1 ) / width;\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\n\n\t\t\t\tconditionalDataArray[ i ] = ( col + 0.5 ) / width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispose();\n\n\t\tconst { marginalWeights, conditionalWeights } = this;\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\tconst totalSumWhole = ~ ~ totalSumValue;\n\t\tconst totalSumDecimal = ( totalSumValue - totalSumWhole );\n\t\tthis.totalSumWhole = totalSumWhole;\n\t\tthis.totalSumDecimal = totalSumDecimal;\n\n\t\tthis.map = map;\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion, Matrix4 } from 'three';\n\nconst LIGHT_PIXELS = 6;\nconst RECT_AREA_LIGHT = 0;\nconst CIRC_AREA_LIGHT = 1;\nconst SPOT_LIGHT = 2;\nconst DIR_LIGHT = 3;\nconst POINT_LIGHT = 4;\nexport class LightsInfoUniformStruct {\n\n\tconstructor() {\n\n\t\tconst tex = new DataTexture( new Float32Array( 4 ), 1, 1 );\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = FloatType;\n\t\ttex.wrapS = ClampToEdgeWrapping;\n\t\ttex.wrapT = ClampToEdgeWrapping;\n\t\ttex.generateMipmaps = false;\n\n\t\tthis.tex = tex;\n\t\tthis.count = 0;\n\n\t}\n\n\tupdateFrom( lights, iesTextures = [] ) {\n\n\t\tconst tex = this.tex;\n\t\tconst pixelCount = Math.max( lights.length * LIGHT_PIXELS, 1 );\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\n\t\tif ( tex.image.width !== dimension ) {\n\n\t\t\ttex.dispose();\n\n\t\t\ttex.image.data = new Float32Array( dimension * dimension * 4 );\n\t\t\ttex.image.width = dimension;\n\t\t\ttex.image.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = tex.image.data;\n\n\t\tconst u = new Vector3();\n\t\tconst v = new Vector3();\n\t\tconst m = new Matrix4();\n\t\tconst worldQuaternion = new Quaternion();\n\t\tconst eye = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst up = new Vector3();\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst l = lights[ i ];\n\n\t\t\tconst baseIndex = i * LIGHT_PIXELS * 4;\n\t\t\tlet index = 0;\n\n\t\t\t// sample 1\n\t\t    // position\n\t\t\tl.getWorldPosition( v );\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t// type\n\t\t\tlet type = RECT_AREA_LIGHT;\n\t\t\tif ( l.isRectAreaLight && l.isCircular ) {\n\n\t\t\t\ttype = CIRC_AREA_LIGHT;\n\n\t\t\t} else if ( l.isSpotLight ) {\n\n\t\t\t\ttype = SPOT_LIGHT;\n\n\t\t\t} else if ( l.isDirectionalLight ) {\n\n\t\t\t\ttype = DIR_LIGHT;\n\n\t\t\t} else if ( l.isPointLight ) {\n\n\t\t\t\ttype = POINT_LIGHT;\n\n\t\t\t}\n\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = type;\n\n\t\t\t// sample 2\n\t\t\t// color\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.r;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.g;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.b;\n\n\t\t\t// intensity\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.intensity;\n\n\t\t\tl.getWorldQuaternion( worldQuaternion );\n\n\t\t\tif ( l.isRectAreaLight ) {\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\t// v vector\n\t\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t\t// area\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.cross( v ).length() * ( l.isCircular ? ( Math.PI / 4.0 ) : 1.0 );\n\n\t\t\t} else if ( l.isSpotLight ) {\n\n\t\t\t\tconst radius = l.radius;\n\t\t\t\teye.setFromMatrixPosition( l.matrixWorld );\n\t\t\t\ttarget.setFromMatrixPosition( l.target.matrixWorld );\n\t\t\t\tm.lookAt( eye, target, up );\n\t\t\t\tworldQuaternion.setFromRotationMatrix( m );\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tu.set( 1, 0, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\t// v vector\n\t\t\t\tv.set( 0, 1, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t\t// area\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.PI * radius * radius;\n\n\t\t\t\t// sample 5\n\t\t\t\t// radius\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = radius;\n\n\t\t\t\t// near\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.shadow.camera.near;\n\n\t\t\t\t// decay\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\n\n\t\t\t\t// distance\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\n\n\t\t\t\t// sample 6\n\t\t\t\t// coneCos\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle );\n\n\t\t\t\t// penumbraCos\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle * ( 1 - l.penumbra ) );\n\n\t\t\t\t// iesProfile\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = iesTextures.indexOf( l.iesTexture );\n\n\t\t\t} else if ( l.isPointLight ) {\n\n\t\t\t\tconst worldPosition = l.getWorldPosition( u );\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\tindex += 4;\n\n\t\t\t\t// sample 5\n\t\t\t\tindex += 2;\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\n\n\t\t\t} else if ( l.isDirectionalLight ) {\n\n\t\t\t\tconst worldPosition = l.getWorldPosition( u );\n\t\t\t\tconst targetPosition = l.target.getWorldPosition( v );\n\n\t\t\t\ttarget.subVectors( worldPosition, targetPosition ).normalize();\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttex.needsUpdate = true;\n\t\tthis.count = lights.length;\n\n\t}\n\n}\n","import {\n\tClampToEdgeWrapping,\n\tColor,\n\tFloatType,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tNoToneMapping,\n\tRGBAFormat,\n\tWebGLArrayRenderTarget,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { IESLoader } from '../utils/IESLoader.js';\n\nconst prevColor = new Color();\nexport class IESProfilesTexture extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = FloatType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = ClampToEdgeWrapping;\n\t\ttex.wrapT = ClampToEdgeWrapping;\n\t\ttex.generateMipmaps = false;\n\n\t\ttex.updateFrom = ( ...args ) => {\n\n\t\t\tthis.updateFrom( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t\tthis.iesLoader = new IESLoader();\n\n\t}\n\n\tasync updateFrom( renderer, textures ) {\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\n\t\tconst depth = textures.length || 1;\n\t\tthis.setSize( 360, 180, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\t\t\tif ( texture ) {\n\n\t\t\t\t// revert to default texture transform before rendering\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t\ttexture.matrix.identity();\n\n\t\t\t\tfsQuad.material.map = texture;\n\t\t\t\tfsQuad.material.transparent = true;\n\n\t\t\t\trenderer.setRenderTarget( this, i );\n\t\t\t\tfsQuad.render( renderer );\n\n\t\t\t\t// restore custom texture transform\n\t\t\t\ttexture.updateMatrix();\n\t\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t\tfsQuad.dispose();\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n","import { FloatAttributeTextureArray } from './FloatAttributeTextureArray.js';\n\nexport class AttributesTextureArray extends FloatAttributeTextureArray {\n\n\tupdateNormalAttribute( attr ) {\n\n\t\tthis.updateAttribute( 0, attr );\n\n\t}\n\n\tupdateTangentAttribute( attr ) {\n\n\t\tthis.updateAttribute( 1, attr );\n\n\t}\n\n\tupdateUvAttribute( attr ) {\n\n\t\tthis.updateAttribute( 2, attr );\n\n\t}\n\n\tupdateColorAttribute( attr ) {\n\n\t\tthis.updateAttribute( 3, attr );\n\n\t}\n\n\tupdateFrom( normal, tangent, uv, color ) {\n\n\t\tthis.setAttributes( [ normal, tangent, uv, color ] );\n\n\t}\n\n}\n","import { DataArrayTexture, FloatType, RGBAFormat } from 'three';\nimport { FloatVertexAttributeTexture } from 'three-mesh-bvh';\n\nfunction copyArrayToArray( fromArray, fromStride, toArray, toStride, offset ) {\n\n\tif ( fromStride > toStride ) {\n\n\t\tthrow new Error();\n\n\t}\n\n\t// scale non-float values to their normalized range\n\tconst count = fromArray.length / fromStride;\n\tconst bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\n\tlet maxValue = 1.0;\n\tswitch ( fromArray.constructor ) {\n\n\tcase Uint8Array:\n\tcase Uint16Array:\n\tcase Uint32Array:\n\t\tmaxValue = 2 ** bpe - 1;\n\t\tbreak;\n\n\tcase Int8Array:\n\tcase Int16Array:\n\tcase Int32Array:\n\t\tmaxValue = 2 ** ( bpe - 1 ) - 1;\n\t\tbreak;\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tconst i4 = 4 * i;\n\t\tconst is = fromStride * i;\n\t\tfor ( let j = 0; j < toStride; j ++ ) {\n\n\t\t\ttoArray[ offset + i4 + j ] = fromStride >= j + 1 ? fromArray[ is + j ] / maxValue : 0;\n\n\t\t}\n\n\t}\n\n}\n\nexport class FloatAttributeTextureArray extends DataArrayTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._textures = [];\n\t\tthis.type = FloatType;\n\t\tthis.format = RGBAFormat;\n\t\tthis.internalFormat = 'RGBA32F';\n\n\t}\n\n\tupdateAttribute( index, attr ) {\n\n\t\t// update the texture\n\t\tconst tex = this._textures[ index ];\n\t\ttex.updateFrom( attr );\n\n\t\t// ensure compatibility\n\t\tconst baseImage = tex.image;\n\t\tconst image = this.image;\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height ) {\n\n\t\t\tthrow new Error( 'FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.' );\n\n\t\t}\n\n\t\t// update the image\n\t\tconst { width, height, data } = image;\n\t\tconst length = width * height * 4;\n\t\tconst offset = length * index;\n\t\tlet itemSize = attr.itemSize;\n\t\tif ( itemSize === 3 ) {\n\n\t\t\titemSize = 4;\n\n\t\t}\n\n\t\t// copy the data\n\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tsetAttributes( attrs ) {\n\n\t\t// ensure the attribute count\n\t\tconst itemCount = attrs[ 0 ].count;\n\t\tconst attrsLength = attrs.length;\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\tif ( attrs[ i ].count !== itemCount ) {\n\n\t\t\t\tthrow new Error( 'FloatAttributeTextureArray: All attributes must have the same item count.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize all textures\n\t\tconst textures = this._textures;\n\t\twhile ( textures.length < attrsLength ) {\n\n\t\t\tconst tex = new FloatVertexAttributeTexture();\n\t\t\ttextures.push( tex );\n\n\t\t}\n\n\t\twhile ( textures.length > attrsLength ) {\n\n\t\t\ttextures.pop();\n\n\t\t}\n\n\t\t// update all textures\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\ttextures[ i ].updateFrom( attrs[ i ] );\n\n\t\t}\n\n\t\t// determine if we need to create a new array\n\t\tconst baseTexture = textures[ 0 ];\n\t\tconst baseImage = baseTexture.image;\n\t\tconst image = this.image;\n\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength ) {\n\n\t\t\timage.width = baseImage.width;\n\t\t\timage.height = baseImage.height;\n\t\t\timage.depth = attrsLength;\n\t\t\timage.data = new Float32Array( image.width * image.height * image.depth * 4 );\n\n\t\t}\n\n\t\t// copy the other texture data into the data array texture\n\t\tconst { data, width, height } = image;\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\tconst tex = textures[ i ];\n\t\t\tconst length = width * height * 4;\n\t\t\tconst offset = length * i;\n\n\t\t\tlet itemSize = attrs[ i ].itemSize;\n\t\t\tif ( itemSize === 3 ) {\n\n\t\t\t\titemSize = 4;\n\n\t\t\t}\n\n\t\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\n\n\t\t}\n\n\t\t// reset the texture\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\n}\n"],"names":["parcelRequire","$ilwiq","$d0f249dd9f03ac59$var$renderTask","_renderer","_fsQuad","_blendQuad","_primaryTarget","_blendTargets","_sobolTarget","alpha","camera","material","this","blendMaterial","blendTarget1","blendTarget2","opacity","samples","blending","NoBlending","NormalBlending","w","width","h","height","resolution","set","sobolTexture","texture","seed","tilesX","tiles","x","tilesY","y","totalTiles","dprInv","getPixelRatio","cameraWorldMatrix","copy","matrixWorld","invProjectionMatrix","projectionMatrixInverse","cameraType","projectionMatrix","elements","isEquirectCamera","setDefine","ogRenderTarget","getRenderTarget","ogAutoClear","autoClear","tx","ty","stableTiles","tileIndex","_currentTile","setRenderTarget","setScissorTest","setScissor","Math","ceil","render","target1","target2","round","$d0f249dd9f03ac59$var$ogClearColor","Color","$d0f249dd9f03ac59$export$196da6cc71a4331","v","target","_alpha","dispose","reset","constructor","renderer","Vector2","stableNoise","$RPVlj","FullScreenQuad","$2JSgM","BlendMaterial","_task","$9kitj","SobolNumberMapGenerator","generate","WebGLRenderTarget","format","RGBAFormat","type","FloatType","setSize","ogClearAlpha","getClearAlpha","getClearColor","setClearColor","clearColor","update","call","next","$1fe9e194dadaa0ff$export$70ee8b3cbd6f21d8","$9fZ6X","MaterialBase","parameters","super","uniforms","value","vertexShader","fragmentShader","setValues","$6ca44f672d576995$var$SobolNumbersMaterial","$2CHzc","shaderSobolCommon","shaderSobolGeneration","$6ca44f672d576995$export$4e8e5459f15b1dca","dimensions","minFilter","NearestFilter","magFilter","generateMipmaps","ogTarget","quad","$1e90ecd04fff0330$var$generateSobolFunctionVariants","dim","$1e90ecd04fff0330$var$generateSobolSampleFunctions","utype","vtype","num","components","combineValues","$1e90ecd04fff0330$export$4c014dbb3981624d","$1e90ecd04fff0330$export$b1f9945bd75fa861","$1e90ecd04fff0330$export$7ece96179554dcb7","$fc1143d2ee906d9d$export$b42762e2bf679e84","initialized","Boolean","bvh","scene","objects","Array","isArray","geometry","BufferGeometry","materials","textures","lights","staticGeometryGenerator","$8Zfx2","StaticGeometryGenerator","attributes","i","l","length","traverse","c","isMesh","normalMapRequired","normalMap","$jM3IF","setCommonAttributes","isRectAreaLight","isSpotLight","push","textureSet","Set","getMaterials","forEach","key","isTexture","add","materialIndexAttribute","getGroupMaterialIndicesAttribute","setAttribute","clearGroups","MeshBVH","from","refit","$465cbee6efe1dae1$var$isTypedArray","arr","buffer","ArrayBuffer","$465cbee6efe1dae1$export$c80603c061964928","ignoreKeys","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","a","b","Object","has","Error","aIsElement","Element","bIsElement","Image","src","aIsImageBitmap","ImageBitmap","bIsImageBitmap","equals","aIsTypedArray","bIsTypedArray","clear","hasOwnProperty","Function","key1","keys","values","result","delete","process","object","replaced","processMaterial","foundMaterial","otherMaterial","image","foundTexture","retained","$f1d46319b05d893e$export$baf85f88dacad6d5","PerspectiveCamera","bokehSize","size","fStop","getFocalLength","args","apertureBlades","apertureRotation","focusDistance","anamorphicRatio","$2c39bed40281e07d$export$6503f7c8e24ae98b","Camera","$983bac6297e5cd71$export$920191b129a29c0","SpotLight","iesTexture","radius","$da3d2bb2945c982a$export$9641f8e91392f35d","RectAreaLight","isCircular","$88425f7125b6e46c$var$_direction","Vector3","$88425f7125b6e46c$export$38d6a241e670a287","$dbdMq","ProceduralEquirectTexture","topColor","bottomColor","exponent","generationCallback","polar","uv","coord","color","setFromSpherical","t","lerpColors","other","$9986fde00d79bc96$var$_uv","$9986fde00d79bc96$var$_coord","$9986fde00d79bc96$var$_polar","Spherical","$9986fde00d79bc96$var$_color","$9986fde00d79bc96$export$ab88b3c5fea10066","DataTexture","Float32Array","EquirectangularReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","LinearFilter","needsUpdate","data","theta","PI","phi","i4","r","g","$ac13547279de9cd0$var$PMREMCopyMaterial","envMap","blur","$jNhCl","shaderUtils","$ac13547279de9cd0$export$13ef63fd7e562136","pmremGenerator","PMREMGenerator","copyQuad","renderTarget","pmremTarget","fromEquirectangular","prevRenderTarget","prevClear","readRenderTargetPixels","wrapS","wrapT","mapping","$52f95bc4e24e9612$var$IESLamp","text1","_self","textArray","split","line1","lineNumber","textToArray","text","trim","replace","readArray","count","array","lineData","Number","verAngles","horAngles","candelaValues","tiltData","angles","mulFactors","includes","line","lampToLumGeometry","numAngles","readTilt","lumens","multiplier","numVerAngles","numHorAngles","gonioType","units","readLampValues","ballFactor","blpFactor","inputWatts","readLampFactors","i1","i2","j","maxVal","i3","j1","$52f95bc4e24e9612$export$f1ffec369846389b","Loader","_getIESValues","iesLamp","interpolateCandelaValues","phiIndex","thetaIndex","startTheta","endTheta","startPhi","endPhi","i5","deltaTheta","deltaPhi","t1","t2","nextThetaIndex","v1","MathUtils","lerp","v2","startTheta1","endTheta1","i6","floor","load","url","onLoad","onProgress","onError","loader","FileLoader","manager","setResponseType","setCrossOrigin","crossOrigin","setWithCredentials","withCredentials","setPath","path","setRequestHeader","requestHeader","RedFormat","undefined","parse","$63d273140796a952$export$e6c92f54dc85f279","transparent","depthWrite","depthTest","defines","USE_SLIDER","sigma","threshold","kSigma","map","$60ded07f88e52847$export$8af0c82d10044f6a","graphFunctionSnippet","_graphFunctionSnippet","thickness","graphCount","graphDisplay","Vector4","overlay","xRange","yRange","colors","convertSRGBToLinear","onBeforeCompile","shader","customProgramCacheKey","$6b5ea45f30e12757$export$746cbc9e65f5bcb8","onBeforeRender","physicalCamera","backgroundMap","FEATURE_MIS","FEATURE_DOF","FEATURE_BACKGROUND_MAP","TRANSPARENT_TRAVERSALS","CAMERA_TYPE","ATTR_NORMAL","ATTR_TANGENT","ATTR_UV","ATTR_COLOR","bounces","$iyhQ7","PhysicalCameraUniform","MeshBVHUniformStruct","attributesArray","$6Q19u","AttributesTextureArray","UIntVertexAttributeTexture","$laA5G","MaterialsTexture","$12pjC","RenderTarget2DArray","$TWVPU","LightsInfoUniformStruct","iesProfiles","$8nCwU","IESProfilesTexture","Matrix4","backgroundBlur","environmentIntensity","environmentRotation","envMapInfo","$kAJM1","EquirectHdrInfoUniform","filterGlossyFactor","backgroundAlpha","$aRxvh","shaderRandFunctions","shaderSobolSampling","shaderStructs","shaderIntersectFunction","$5Wq6T","shaderMaterialStructs","shaderLightStruct","$9XfmY","shaderLayerTexelFetchFunctions","$fcAdp","shaderMaterialSampling","$1RTaa","shaderEnvMapSampling","$22srR","shaderLightSampling","$f69686fae5159582$var$MATERIAL_STRIDE","$f69686fae5159582$var$MATERIAL_PIXELS","$f69686fae5159582$export$ae96f3619813ce17","threeCompatibilityTransforms","setCastShadow","materialIndex","cast","getCastShadow","setMatte","matte","getMatte","updateFrom","getTexture","def","hash","$kOapr","getTextureHash","uniqueTextureLookup","getField","writeTextureMatrixToArray","textureKey","offset","specularMap","displacementMap","bumpMap","roughnessMap","metalnessMap","alphaMap","emissiveMap","clearcoatMap","clearcoatNormalMap","clearcoatRoughnessMap","iridescenceMap","iridescenceThicknessMap","specularIntensityMap","specularColorMap","transmissionMap","thicknessMap","sheenColorMap","sheenRoughnessMap","getUVTransformTexture","matrix","index","pixelCount","dimension","sqrt","uniqueTextures","reduceTexturesToUniqueSources","floatArray","l1","m","emissive","normalScale","clearcoatNormalScale","sheenColor","iridescenceThicknessRange","specularColor","isThinFilm","Infinity","attenuationColor","alphaTest","transmission","side","FrontSide","BackSide","DoubleSide","vertexColors","flatShading","$f2608d3a8976ec83$export$62c3d260e4e2abca","source","uuid","encoding","$f2608d3a8976ec83$export$3ea341cb9862695a","sourceSet","tex","$0c199d70d276a61d$var$prevColor","$0c199d70d276a61d$export$dbbaa51cb2d0b2f7","WebGLArrayRenderTarget","args1","UnsignedByteType","setTextures","fsQuad","MeshBasicMaterial","prevToneMapping","toneMapping","prevAlpha","depth","NoToneMapping","matrixAutoUpdate","identity","updateMatrix","$bmrjs","$b114119888481524$export$aba3482f45fc2e55","shaderGGXFunctions","$bQHTv","shaderSheenFunctions","$6wwLz","shaderIridescenceFunctions","$8456ef8cb9b1d3a5$export$75d2a701aae03ef9","$8a06998b2d01b1dc$export$300995c3bffdc4dd","$4bff25ed6e99776b$export$edc525d01b11600f","$15c587eb667da097$export$c4e96847515c3dca","$17c1d5e781a3625a$export$72ea2c7ee2a3cb14","$73f58bd56b982788$export$a7fa944525e63a10","$kLfIo","$d8193d8a8d6141d1$export$2e27c77dea3c9d73","PhysicalCamera","$efdaad16b8cd905b$var$binarySearchFindClosestIndexOf","targetValue","lower","upper","mid","$efdaad16b8cd905b$var$colorToLuminance","$efdaad16b8cd905b$export$e5a77e5d6a85a862","marginalWeights","conditionalWeights","totalSumWhole","totalSumDecimal","hdr","clone","Source","newData","HalfFloatType","DataUtils","fromHalfFloat","flipY","ogData","slice","ogIndex","newIndex","$efdaad16b8cd905b$var$preprocessEnvMap","pdfConditional","cdfConditional","pdfMarginal","cdfMarginal","totalSumValue","cumulativeWeightMarginal","cumulativeRowWeight","weight","marginalDataArray","conditionalDataArray","row","y1","col","$0a82d9ce12cf98b8$export$bb02c0eb15767758","iesTextures","max","u","worldQuaternion","Quaternion","eye","up","baseIndex","getWorldPosition","z","isDirectionalLight","isPointLight","intensity","getWorldQuaternion","applyQuaternion","cross","setFromMatrixPosition","lookAt","setFromRotationMatrix","shadow","near","decay","distance","cos","angle","penumbra","indexOf","worldPosition","targetPosition","subVectors","normalize","$619e5bed458602b0$var$prevColor","$619e5bed458602b0$export$cc46c2e928f0cae0","iesLoader","$77Fts","IESLoader","async","$7Ie7O","$4fa87e2831d7f36b$export$2e089d4ee1364df8","FloatAttributeTextureArray","updateNormalAttribute","attr","updateAttribute","updateTangentAttribute","updateUvAttribute","updateColorAttribute","normal","tangent","setAttributes","$59d79964e8fc761c$var$copyArrayToArray","fromArray","fromStride","toArray","toStride","bpe","BYTES_PER_ELEMENT","maxValue","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","is","$59d79964e8fc761c$export$74918e5550c6edfc","DataArrayTexture","_textures","internalFormat","baseImage","itemSize","attrs","itemCount","attrsLength","FloatVertexAttributeTexture","pop","l2"],"version":3,"file":"areaLight.5162c8c6.js.map"}